# Design Document: Rust-PEG Parser Rewrite

## Overview

This design document describes the architecture for rewriting the Crusty parser using the rust-peg parser generator. The rewrite addresses fundamental issues with the current hand-written recursive descent parser, particularly around backtracking and ambiguous grammar handling. The new parser will use a formal PEG (Parsing Expression Grammar) defined using rust-peg's peg! macro, which eliminates ambiguity through ordered choice and provides better error messages.

The design maintains complete compatibility with the existing AST structure, ensuring that downstream compiler phases (semantic analysis, code generation, pretty printing) require no changes.

## Architecture

### High-Level Architecture

```
┌─────────────────┐
│  Source Code    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Rust-PEG       │  ← Generated from peg! macro
│  Parser         │     with embedded actions
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  AST (ast.rs)   │  ← Built directly by grammar actions
└─────────────────┘
```

### Component Breakdown

1. **Grammar Module (parser.rs)**: PEG grammar defined in peg! macro with embedded Rust actions
2. **Parser Functions**: Generated by rust-peg from grammar rules
3. **AST Builders**: Inline Rust code within grammar rules that construct AST nodes
4. **Error Handler**: rust-peg's built-in error reporting with expected! macro

### Key Design Decisions

1. **Integrated Grammar and Actions**: Grammar rules and AST building code live together in peg! macro
2. **Maintain AST Compatibility**: No changes to `ast.rs` structures
3. **Precedence Climbing for Expressions**: Use rust-peg's precedence! macro for operator precedence
4. **Ordered Choice for Ambiguity**: PEG's ordered choice resolves cast vs. parenthesized expression ambiguity
5. **Direct AST Construction**: No intermediate parse tree - actions build AST directly

## Components and Interfaces

### 1. Grammar Structure

The grammar will be defined using rust-peg's peg! macro and organized into logical sections:

```rust
peg::parser! {
    pub grammar crusty_parser() for str {
        // ============================================================================
        // WHITESPACE AND COMMENTS
        // ============================================================================
        
        rule _ = quiet!{(whitespace() / comment())*}
        rule __ = quiet!{(whitespace() / comment())+}
        
        rule whitespace() = [' ' | '\t' | '\r' | '\n']
        rule comment() = line_comment() / block_comment()
        rule line_comment() = "//" (!"\n" [_])* "\n"?
        rule block_comment() = "/*" (!"*/" [_])* "*/"
        
        // ============================================================================
        // KEYWORDS
        // ============================================================================
        
        rule kw_let() = "let" !ident_char()
        rule kw_var() = "var" !ident_char()
        rule kw_const() = "const" !ident_char()
        // ... (all keywords)
        
        // ============================================================================
        // LITERALS
        // ============================================================================
        
        pub rule int_literal() -> Literal
            = n:$(['0'..='9']+) { Literal::Int(n.parse().unwrap()) }
        
        pub rule float_literal() -> Literal
            = n:$(['0'..='9']+ "." ['0'..='9']+) { Literal::Float(n.parse().unwrap()) }
        
        pub rule string_literal() -> Literal
            = "\"" s:$((!"\""[_])*) "\"" { Literal::String(s.to_string()) }
        
        // ... (more literals)
        
        // ============================================================================
        // IDENTIFIERS
        // ============================================================================
        
        rule ident_char() = ['a'..='z' | 'A'..='Z' | '0'..='9' | '_']
        
        pub rule ident() -> Ident
            = !keyword() n:$((['a'..='z' | 'A'..='Z' | '_']) ident_char()*)
            { Ident::new(n) }
        
        // ============================================================================
        // TYPES
        // ============================================================================
        
        pub rule type_expr() -> Type = precedence!{
            t:@ "*" { Type::Pointer(Box::new(t)) }
            --
            "&" "mut"? _ t:@ { Type::Reference(Box::new(t), true) }
            --
            t:@ "[" _ size:expr()? _ "]" { Type::Array(Box::new(t), size) }
            --
            n:ident() "<" _ types:type_list() _ ">" { Type::Generic(n, types) }
            --
            n:primitive_type() { Type::Primitive(n) }
            n:ident() { Type::Ident(n) }
            "(" _ t:type_expr() _ ")" { t }
        }
        
        // ============================================================================
        // EXPRESSIONS
        // ============================================================================
        
        pub rule expr() -> Expression = precedence!{
            // Comma operator (lowest precedence)
            l:(@) _ "," _ r:@ { Expression::Comma(Box::new(l), Box::new(r)) }
            --
            // Assignment
            l:(@) _ "=" _ r:@ { Expression::Assign(Box::new(l), Box::new(r)) }
            --
            // Logical OR
            l:(@) _ "||" _ r:@ { Expression::Binary(BinOp::LogicalOr, Box::new(l), Box::new(r)) }
            --
            // Logical AND
            l:(@) _ "&&" _ r:@ { Expression::Binary(BinOp::LogicalAnd, Box::new(l), Box::new(r)) }
            --
            // Equality
            l:(@) _ "==" _ r:@ { Expression::Binary(BinOp::Eq, Box::new(l), Box::new(r)) }
            l:(@) _ "!=" _ r:@ { Expression::Binary(BinOp::Ne, Box::new(l), Box::new(r)) }
            --
            // Comparison
            l:(@) _ "<" _ r:@ { Expression::Binary(BinOp::Lt, Box::new(l), Box::new(r)) }
            l:(@) _ ">" _ r:@ { Expression::Binary(BinOp::Gt, Box::new(l), Box::new(r)) }
            // ... more operators
            --
            // Addition/Subtraction
            l:(@) _ "+" _ r:@ { Expression::Binary(BinOp::Add, Box::new(l), Box::new(r)) }
            l:(@) _ "-" _ r:@ { Expression::Binary(BinOp::Sub, Box::new(l), Box::new(r)) }
            --
            // Multiplication/Division
            l:(@) _ "*" _ r:@ { Expression::Binary(BinOp::Mul, Box::new(l), Box::new(r)) }
            l:(@) _ "/" _ r:@ { Expression::Binary(BinOp::Div, Box::new(l), Box::new(r)) }
            --
            // Prefix operators
            "-" _ e:@ { Expression::Unary(UnOp::Neg, Box::new(e)) }
            "!" _ e:@ { Expression::Unary(UnOp::Not, Box::new(e)) }
            --
            // Primary expressions
            e:primary() { e }
        }
        
        rule primary() -> Expression
            = cast_expr()      // Try cast first
            / call_expr()
            / field_access()
            / paren_expr()
            / literal_expr()
            / ident_expr()
        
        rule cast_expr() -> Expression
            = "(" _ t:type_expr() _ ")" _ "(" _ e:expr() _ ")"
            { Expression::Cast(Box::new(e), t) }
        
        rule paren_expr() -> Expression
            = "(" _ e:expr() _ ")" { e }
        
        // ============================================================================
        // STATEMENTS
        // ============================================================================
        
        pub rule statement() -> Statement
            = let_stmt()
            / var_stmt()
            / if_stmt()
            / while_stmt()
            / return_stmt()
            / expr_stmt()
        
        // ============================================================================
        // ITEMS
        // ============================================================================
        
        pub rule item() -> Item
            = function()
            / struct_def()
            / enum_def()
            / typedef()
        
        // ============================================================================
        // FILE
        // ============================================================================
        
        pub rule file() -> File
            = _ items:item() ** _ _ { File { items } }
    }
}
```

### 2. Parser Interface

```rust
pub struct Parser {
    // No internal state needed - rust-peg handles everything
}

impl Parser {
    /// Create a new parser from source code
    pub fn new(source: &str) -> Result<Self, ParseError> {
        // Validate source can be parsed
        Ok(Self {})
    }

    /// Parse a complete source file into a File AST
    pub fn parse_file(&mut self, source: &str) -> Result<File, ParseError> {
        crusty_parser::file(source)
            .map_err(|e| convert_peg_error(e, source))
    }
}
```

### 3. Error Conversion

```rust
fn convert_peg_error(error: peg::error::ParseError<peg::str::LineCol>, source: &str) -> ParseError {
    let location = error.location;
    let line = location.line;
    let column = location.column;
    
    let expected = error.expected.tokens()
        .map(|t| t.to_string())
        .collect();
    
    let span = Span::new(line, column, line, column);
    let message = format!("Parse error at {}:{}", line, column);
    let found = extract_found_token(source, line, column);
    
    ParseError::new(span, message, expected, found)
}
```

## Data Models

### Grammar Rules (rust-peg)

The grammar will define rules that map closely to AST node types, with embedded actions:

- **file**: Top-level rule matching entire source file, returns `File`
- **item**: Function, struct, enum, typedef, or macro definition, returns `Item`
- **statement**: Let, var, const, if, while, for, return, etc., returns `Statement`
- **expr**: Expressions with operator precedence using precedence! macro, returns `Expression`
- **type_expr**: Type expressions (primitives, pointers, references, etc.), returns `Type`
- **literal**: Integer, float, string, char, bool, null literals, returns `Literal`
- **ident**: Identifiers, returns `Ident`
- **attribute**: Attribute syntax `#[...]`, returns `Attribute`

### AST Nodes (existing)

No changes to existing AST structures in `ast.rs`. The AST builder will construct:

- `File { items, doc_comments }`
- `Item::{Function, Struct, Enum, Typedef, MacroDefinition}`
- `Statement::{Let, Var, Const, Expr, Return, If, While, For, ...}`
- `Expression::{Literal, Ident, Binary, Unary, Call, Cast, ...}`
- `Type::{Primitive, Ident, Pointer, Reference, Array, ...}`

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

Before writing correctness properties, let me analyze the acceptance criteria from the requirements:

### Acceptance Criteria Testing Prework

**Requirement 1: Formal Grammar Definition**

1.1. THE Grammar SHALL be defined in pest syntax in a `.pest` file
  Thoughts: This is about the implementation structure, not a functional requirement that can be tested with properties.
  Testable: no

1.2. THE Grammar SHALL include all Crusty language constructs
  Thoughts: This is about completeness of the grammar. We can test this by ensuring all existing test cases parse correctly.
  Testable: yes - property

1.3. THE Grammar SHALL use PEG ordered choice to resolve ambiguities
  Thoughts: This is about the grammar implementation technique, not a testable functional property.
  Testable: no

1.4. THE Grammar SHALL be documented with comments
  Thoughts: This is about code quality, not functional behavior.
  Testable: no

1.5. THE Grammar SHALL handle whitespace and comments implicitly
  Thoughts: We can test that whitespace and comments don't affect parsing results.
  Testable: yes - property

1.6. THE Grammar SHALL define precedence for operators through grammar structure
  Thoughts: We can test that operator precedence is correct by parsing expressions and checking the AST structure.
  Testable: yes - property

1.7. THE Grammar SHALL support all existing Crusty syntax
  Thoughts: This is the same as 1.2.
  Testable: yes - property (covered by 1.2)

**Requirement 2: Cast Expression Parsing**

2.1. WHEN parsing `(Type)(expr)`, THE Parser SHALL correctly identify it as a cast expression
  Thoughts: This is testing a specific pattern. We can generate random types and expressions and verify the AST node type.
  Testable: yes - property

2.2. WHEN parsing `(expr)`, THE Parser SHALL correctly identify it as a parenthesized expression
  Thoughts: This is testing a specific pattern. We can generate random expressions and verify they parse correctly.
  Testable: yes - property

2.3. WHEN parsing `(Type)`, THE Parser SHALL correctly identify it as a parenthesized type expression
  Thoughts: This is testing a specific pattern within expressions.
  Testable: yes - example

2.4. THE Parser SHALL distinguish between cast expressions and function calls
  Thoughts: This is about disambiguation. We can test that `(Type)(expr)` is a cast and `func(expr)` is a call.
  Testable: yes - property

2.5. THE Parser SHALL handle nested casts
  Thoughts: We can generate nested cast expressions and verify they parse correctly.
  Testable: yes - property

2.6. THE Parser SHALL handle casts with complex type expressions
  Thoughts: We can generate casts with pointer and reference types and verify they parse.
  Testable: yes - property

**Requirement 3: Error Message Quality**

3.1. WHEN a parse error occurs, THE Parser SHALL report the line number and column number
  Thoughts: For any invalid input, we can verify the error contains position information.
  Testable: yes - property

3.2. WHEN a parse error occurs, THE Parser SHALL report what was expected
  Thoughts: For any invalid input, we can verify the error contains expected token information.
  Testable: yes - property

3.3. WHEN a parse error occurs, THE Parser SHALL report what was found
  Thoughts: For any invalid input, we can verify the error contains found token information.
  Testable: yes - property

3.4. THE Parser SHALL provide error messages that are more descriptive than the current parser
  Thoughts: This is subjective and hard to test automatically.
  Testable: no

3.5. THE Parser SHALL leverage pest's built-in error reporting
  Thoughts: This is an implementation detail.
  Testable: no

3.6. WHEN multiple parse errors exist, THE Parser SHALL report the first error
  Thoughts: We can test that only one error is reported for invalid input.
  Testable: yes - example

**Requirement 4: AST Compatibility**

4.1. THE Parser SHALL produce AST nodes that match the existing `ast.rs` definitions
  Thoughts: For any valid input, we can verify the AST structure matches expected types.
  Testable: yes - property

4.2. THE Parser SHALL preserve all AST node types
  Thoughts: This is covered by 4.1.
  Testable: yes - property (covered by 4.1)

4.3. THE Parser SHALL preserve all AST node fields and their semantics
  Thoughts: This is covered by 4.1.
  Testable: yes - property (covered by 4.1)

4.4. THE Parser SHALL convert pest's parse tree to the existing AST structure
  Thoughts: This is an implementation detail.
  Testable: no

4.5. THE Parser SHALL maintain compatibility with existing compiler phases
  Thoughts: We can test this by running existing semantic analyzer tests.
  Testable: yes - property

**Requirement 5: Test Preservation**

5.1-5.6. THE Parser SHALL pass all existing tests
  Thoughts: These are specific test suites that must pass. Each test is an example.
  Testable: yes - example (for each test suite)

**Requirement 6: Language Feature Support**

6.1-6.15. THE Parser SHALL parse [various language features]
  Thoughts: For each feature, we can generate random valid instances and verify they parse correctly.
  Testable: yes - property (for each feature)

**Requirement 7: Performance**

7.1. THE Parser SHALL parse files at a rate comparable to or faster than the current parser
  Thoughts: This is a performance test, not a correctness property.
  Testable: no

7.2. THE Parser SHALL not introduce performance regressions greater than 20%
  Thoughts: This is a performance test.
  Testable: no

7.3. THE Parser SHALL handle large source files without excessive memory usage
  Thoughts: This is a performance/resource test.
  Testable: no

7.4. THE Parser SHALL leverage pest's optimized parsing algorithms
  Thoughts: This is an implementation detail.
  Testable: no

**Requirement 8: Maintainability**

8.1-8.6. [Maintainability requirements]
  Thoughts: These are all about code organization and documentation, not functional behavior.
  Testable: no

**Requirement 9: Integration**

9.1. THE Parser SHALL expose the same public API
  Thoughts: We can test that the API signature matches.
  Testable: yes - example

9.2. THE Parser SHALL return the same error types
  Thoughts: We can test that errors are of type `ParseError`.
  Testable: yes - property

9.3. THE Parser SHALL work with existing lexer error types
  Thoughts: This is about error type compatibility.
  Testable: yes - example

9.4. THE Parser SHALL not require changes to downstream phases
  Thoughts: This is covered by 4.5.
  Testable: yes - property (covered by 4.5)

9.5. THE Parser SHALL maintain the same module structure
  Thoughts: This is about code organization.
  Testable: no

**Requirement 10: Documentation**

10.1-10.5. [Documentation requirements]
  Thoughts: These are all about documentation quality, not functional behavior.
  Testable: no

### Property Reflection

After reviewing all testable properties, let me identify redundancies:

- Properties 1.2 and 1.7 are identical (grammar completeness)
- Properties 4.1, 4.2, and 4.3 all test AST structure compatibility
- Properties 4.5 and 9.4 both test downstream compatibility
- Properties 3.1, 3.2, and 3.3 can be combined into one comprehensive error reporting property

Consolidated properties:
- Grammar completeness (1.2)
- Whitespace/comment handling (1.5)
- Operator precedence (1.6)
- Cast expression parsing (2.1, 2.2, 2.4, 2.5, 2.6 - can be combined)
- Error reporting (3.1, 3.2, 3.3 - combined)
- AST compatibility (4.1 - covers 4.2, 4.3, 4.5, 9.4)
- Error type compatibility (9.2)
- Language feature support (6.1-6.15 - can be grouped)

### Correctness Properties

**Property 1: Grammar Completeness**
*For any* valid Crusty source code that parses with the old parser, the new pest parser should also parse it successfully and produce an equivalent AST structure.
**Validates: Requirements 1.2, 1.7, 5.1-5.6**

**Property 2: Whitespace Invariance**
*For any* valid Crusty source code, adding or removing whitespace (spaces, tabs, newlines) or comments should not change the resulting AST structure (excluding position information).
**Validates: Requirements 1.5**

**Property 3: Operator Precedence Correctness**
*For any* expression containing multiple operators, the AST structure should reflect the correct precedence and associativity (e.g., `1 + 2 * 3` should parse as `1 + (2 * 3)`).
**Validates: Requirements 1.6**

**Property 4: Cast Expression Disambiguation**
*For any* valid type T and expression E, the pattern `(T)(E)` should parse as a Cast expression node, while `(E)` should parse as the expression E itself (parentheses removed), and `func(E)` should parse as a Call expression.
**Validates: Requirements 2.1, 2.2, 2.4**

**Property 5: Nested Cast Handling**
*For any* valid types T1, T2 and expression E, the pattern `(T1)(T2)(E)` should parse as nested Cast expressions with correct structure.
**Validates: Requirements 2.5**

**Property 6: Complex Type Cast Handling**
*For any* complex type expression (pointers, references, arrays) and expression E, casts like `(int*)(E)` and `(&mut Type)(E)` should parse correctly as Cast expressions.
**Validates: Requirements 2.6**

**Property 7: Error Location Reporting**
*For any* invalid Crusty source code, the parser should produce an error that includes line number, column number, expected tokens, and found token information.
**Validates: Requirements 3.1, 3.2, 3.3**

**Property 8: AST Structure Compatibility**
*For any* valid Crusty source code, the AST produced by the new parser should have the same structure and node types as the AST that would be produced by the old parser (ignoring internal implementation details like spans).
**Validates: Requirements 4.1, 4.2, 4.3, 4.5, 9.4**

**Property 9: Error Type Consistency**
*For any* invalid Crusty source code, the parser should return an error of type `ParseError` with all required fields populated.
**Validates: Requirements 9.2**

**Property 10: Function Parsing**
*For any* valid function declaration (with various return types, parameter lists, and bodies), the parser should produce a Function AST node with correct fields.
**Validates: Requirements 6.1**

**Property 11: Struct Parsing**
*For any* valid struct definition (with fields, methods, and attributes), the parser should produce a Struct AST node with correct fields and methods.
**Validates: Requirements 6.2**

**Property 12: Expression Parsing**
*For any* valid expression (literals, binary ops, unary ops, calls, field access, etc.), the parser should produce the correct Expression AST node type.
**Validates: Requirements 6.8**

**Property 13: Statement Parsing**
*For any* valid statement (let, var, const, if, while, for, switch, return, etc.), the parser should produce the correct Statement AST node type.
**Validates: Requirements 6.7**

**Property 14: Comma Operator Parsing**
*For any* comma-separated expression sequence, the parser should produce Expression::Comma nodes with correct left-to-right associativity and lowest precedence. For for-loops with comma-separated initializers or increments (e.g., `for (int i=1, j=2; i < 100; i++, j+=2)`), the parser should correctly parse the comma-separated lists.
**Validates: Requirements 6.16, 6.17**

## Error Handling

### Error Types

The parser will continue to use the existing `ParseError` type:

```rust
pub struct ParseError {
    pub span: Span,
    pub message: String,
    pub expected: Vec<String>,
    pub found: String,
}
```

### Error Conversion Strategy

Rust-peg provides error information that we'll convert to our format:

1. **Position Mapping**: rust-peg provides line/column directly via LineCol
2. **Expected Tokens**: Extract from error.expected tokens
3. **Found Token**: Extract from source at error location
4. **Message**: Format error message with location and context

### Error Scenarios

1. **Lexical Errors**: Invalid characters, unterminated strings
   - rust-peg will catch these during parsing
   - Convert to ParseError with appropriate message

2. **Syntax Errors**: Unexpected tokens, missing delimiters
   - rust-peg provides expected tokens via expected! macro
   - Convert to ParseError with context

3. **Ambiguity Errors**: Should not occur due to PEG ordered choice
   - If they do, it's a grammar bug to fix

## Testing Strategy

### Dual Testing Approach

The parser will be tested using both unit tests and property-based tests:

**Unit Tests**:
- Specific examples of each language construct
- Edge cases (empty files, only comments, etc.)
- Error conditions (missing semicolons, unclosed braces, etc.)
- Integration with existing test suites

**Property-Based Tests**:
- Universal properties across all inputs
- Minimum 100 iterations per property test
- Each test tagged with: **Feature: parser-pest-rewrite, Property N: [property text]**

### Test Organization

1. **Grammar Tests**: Verify grammar rules parse correctly
   - Test each rule in isolation
   - Test rule combinations

2. **AST Building Tests**: Verify parse tree → AST conversion
   - Test each AST node type
   - Test nested structures

3. **Error Tests**: Verify error reporting
   - Test various syntax errors
   - Verify error message quality

4. **Regression Tests**: Ensure all existing tests pass
   - Run all existing parser test suites
   - Verify no functionality lost

5. **Property Tests**: Verify universal properties
   - Implement each correctness property as a property test
   - Use proptest or quickcheck for generation

### Property Test Configuration

Each property test will:
- Run minimum 100 iterations
- Generate random valid/invalid inputs
- Verify the property holds
- Be tagged with property number and text

Example:
```rust
#[test]
fn property_2_whitespace_invariance() {
    // Feature: parser-rust-peg-rewrite, Property 2: Whitespace Invariance
    proptest!(|(code in valid_crusty_code(), ws in whitespace_variations())| {
        let ast1 = parse(code);
        let ast2 = parse(add_whitespace(code, ws));
        prop_assert_eq!(ast1, ast2);
    });
}
```

### Test Coverage Goals

- 100% of existing parser tests pass
- 100% of grammar rules covered by tests
- 100% of AST node types covered by tests
- All correctness properties implemented as property tests
- All error scenarios covered by unit tests

## Implementation Notes

### Grammar Design Patterns

1. **Whitespace Handling**: Use `_` rule for optional whitespace, `__` for required
   ```rust
   rule _ = quiet!{(whitespace() / comment())*}
   rule __ = quiet!{(whitespace() / comment())+}
   ```

2. **Quiet Rules**: Use `quiet!{}` for rules that shouldn't appear in error messages
   ```rust
   rule whitespace() = quiet!{[' ' | '\t' | '\r' | '\n']}
   ```

3. **Ordered Choice**: Use `/` for alternatives, order matters
   ```rust
   rule primary() -> Expression
       = cast_expr()      // Try cast first
       / paren_expr()     // Then parenthesized
       / literal_expr()
       / ident_expr()
   ```

4. **Operator Precedence**: Use precedence! macro for expressions
   ```rust
   pub rule expr() -> Expression = precedence!{
       l:(@) _ "+" _ r:@ { Expression::Binary(BinOp::Add, Box::new(l), Box::new(r)) }
       l:(@) _ "-" _ r:@ { Expression::Binary(BinOp::Sub, Box::new(l), Box::new(r)) }
       --
       l:(@) _ "*" _ r:@ { Expression::Binary(BinOp::Mul, Box::new(l), Box::new(r)) }
       l:(@) _ "/" _ r:@ { Expression::Binary(BinOp::Div, Box::new(l), Box::new(r)) }
       --
       e:primary() { e }
   }
   ```

5. **Expected Errors**: Use expected!() for better error messages
   ```rust
   rule semicolon() = ";" / expected!("semicolon")
   ```

### Cast Expression Disambiguation

The key to solving the cast expression ambiguity is ordered choice:

```rust
rule primary() -> Expression
    = cast_expr()      // Try cast first: (Type)(expr)
    / paren_expr()     // Then parenthesized: (expr)
    / literal_expr()
    / ident_expr()

rule cast_expr() -> Expression
    = "(" _ t:type_expr() _ ")" _ "(" _ e:expr() _ ")"
    { Expression::Cast(Box::new(e), t) }

rule paren_expr() -> Expression
    = "(" _ e:expr() _ ")" { e }
```

Because PEG uses ordered choice, the parser will try `cast_expr` first. If it matches `(Type)(expr)`, it succeeds. If not, it backtracks and tries `paren_expr`.

### Comma Operator Handling

The comma operator in C has the lowest precedence and is left-associative. It evaluates its left operand, discards the result, then evaluates and returns its right operand. This is particularly important in:

1. **Expression statements**: `i++, --n;` evaluates both expressions
2. **For loop initializers**: `for (int i=1, j=2; ...)`  declares/initializes multiple variables
3. **For loop increments**: `for (...; ...; i++, j+=2)` updates multiple variables

In the precedence! macro, the comma operator is placed at the lowest precedence level:

```rust
pub rule expr() -> Expression = precedence!{
    // Comma operator (lowest precedence)
    l:(@) _ "," _ r:@ { Expression::Comma(Box::new(l), Box::new(r)) }
    --
    // Assignment
    l:(@) _ "=" _ r:@ { Expression::Assign(Box::new(l), Box::new(r)) }
    --
    // ... other operators
}
```

For for-loops, we need special handling to allow comma-separated expressions in initializers and increments:

```rust
rule for_stmt() -> Statement
    = "for" _ "(" _ 
      init:(for_init_list() / expr()?) _ ";" _ 
      cond:expr()? _ ";" _ 
      incr:(expr_list() / expr()?) _ 
      ")" _ body:block()
    { Statement::For { init, cond, incr, body } }

rule for_init_list() -> Vec<Expression>
    = first:for_init() rest:(_ "," _ for_init())* 
    { /* build list */ }

rule expr_list() -> Expression
    = first:expr() rest:(_ "," _ expr())* 
    { /* build comma expression chain */ }
```

This allows parsing of complex for-loops like:
- `for (int i=1, j=2; i < 100; i++, j+=2) { ... }`
- `for (i=0, j=10; i < j; i++, j--) { ... }`

### AST Building Strategy

1. **Direct Construction**: Actions in grammar rules build AST nodes directly
2. **Pattern Matching**: Use Rust pattern matching in actions to construct nodes
3. **Helper Functions**: Create helper functions for complex AST construction
4. **Error Propagation**: Use `?` operator in actions to propagate errors

Example:
```rust
pub rule expr() -> Expression = precedence!{
    l:(@) _ "+" _ r:@ { Expression::Binary(BinOp::Add, Box::new(l), Box::new(r)) }
    l:(@) _ "-" _ r:@ { Expression::Binary(BinOp::Sub, Box::new(l), Box::new(r)) }
    --
    l:(@) _ "*" _ r:@ { Expression::Binary(BinOp::Mul, Box::new(l), Box::new(r)) }
    l:(@) _ "/" _ r:@ { Expression::Binary(BinOp::Div, Box::new(l), Box::new(r)) }
    --
    n:int_literal() { Expression::Literal(n) }
    i:ident() { Expression::Ident(i) }
    "(" _ e:expr() _ ")" { e }
}
```

### Migration Strategy

1. **Phase 1**: Create peg! macro with basic structure and simple rules
2. **Phase 2**: Implement literals, identifiers, and types with actions
3. **Phase 3**: Add expressions using precedence! macro
4. **Phase 4**: Add statements and control flow
5. **Phase 5**: Add items (functions, structs, enums, typedefs)
6. **Phase 6**: Run existing tests, fix issues
7. **Phase 7**: Add property tests
8. **Phase 8**: Performance testing and optimization

### Compatibility Considerations

- Keep existing `Parser::new()` and `parse_file()` API
- Return existing `ParseError` type
- Produce existing AST node types
- No changes required to downstream phases
- Existing tests should pass without modification

## Appendix: Grammar Sketch

Here's a high-level sketch of the grammar structure:

```rust
peg::parser! {
    pub grammar crusty_parser() for str {
        // File structure
        pub rule file() -> File
            = _ items:item() ** _ _ { File { items } }
        
        // Items (top-level declarations)
        pub rule item() -> Item
            = attrs:attribute()* _ i:(function() / struct_def() / enum_def() / typedef() / macro_def())
            { attach_attributes(i, attrs) }
        
        rule function() -> Item
            = vis:visibility()? _ ret:type_expr() _ name:ident() _ 
              "(" _ params:param_list()? _ ")" _ body:block()
            { Item::Function(Function { vis, ret, name, params, body }) }
        
        rule struct_def() -> Item
            = "struct" __ name:ident() _ "{" _ members:(field() / method())* _ "}"
            { Item::Struct(Struct { name, members }) }
        
        // Statements
        pub rule statement() -> Statement
            = let_stmt() / var_stmt() / const_stmt() / if_stmt() / while_stmt() 
            / for_stmt() / switch_stmt() / return_stmt() / break_stmt() 
            / continue_stmt() / expr_stmt()
        
        // Expressions (using precedence! macro)
        pub rule expr() -> Expression = precedence!{
            // Assignment (lowest precedence)
            l:(@) _ "=" _ r:@ { Expression::Assign(Box::new(l), Box::new(r)) }
            --
            // Logical OR
            l:(@) _ "||" _ r:@ { Expression::Binary(BinOp::LogicalOr, Box::new(l), Box::new(r)) }
            --
            // ... more precedence levels
            --
            // Primary expressions
            e:primary() { e }
        }
        
        rule primary() -> Expression
            = cast_expr() / call_expr() / field_access() / paren_expr() 
            / literal_expr() / ident_expr()
        
        // Types
        pub rule type_expr() -> Type = precedence!{
            t:@ "*" { Type::Pointer(Box::new(t)) }
            --
            "&" "mut"? _ t:@ { Type::Reference(Box::new(t), true) }
            --
            t:@ "[" _ size:expr()? _ "]" { Type::Array(Box::new(t), size) }
            --
            n:ident() "<" _ types:type_list() _ ">" { Type::Generic(n, types) }
            --
            n:primitive_type() { Type::Primitive(n) }
            n:ident() { Type::Ident(n) }
            "(" _ t:type_expr() _ ")" { t }
        }
        
        // Literals
        pub rule literal() -> Literal
            = int_literal() / float_literal() / string_literal() 
            / char_literal() / bool_literal() / null_literal()
    }
}
```

This grammar structure provides:
- Clear organization by language construct
- Ordered choice for disambiguation
- Support for all Crusty features
- Direct AST construction via embedded actions
- Extensibility for future features
