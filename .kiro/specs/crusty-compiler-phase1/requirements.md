# Requirements Document

## Introduction

Crusty is a C-like programming language that transpiles to Rust, enabling developers to write code with familiar C syntax while leveraging the safety and performance of the Rust ecosystem. Phase 1 focuses on building two tools: `crustyc` (a bidirectional transpiler that translates between Crusty and Rust source code) and `crustydoc` (a documentation generator that leverages the Linux kernel document object model for self-documented code).

Crusty is designed for transparent integration with the Rust ecosystem:
- **Use Rust crates**: Crusty code can import and use any existing Rust crate or module
- **Create Rust-compatible modules**: Crusty projects can be compiled into crates that native Rust projects can depend on
- **Bidirectional transpilation**: Convert between Crusty and Rust syntax as needed
- **Build system integration**: Works seamlessly with Cargo through build.rs scripts

This phase serves as an experimental platform to determine which C language features can be preserved and which must be excluded from the Crusty dialect to maintain full Rust compatibility and ecosystem interoperability.

## Glossary

- **Crusty**: A C-like programming language that transpiles to Rust
- **crustyc**: The transpiler binary that translates between Crusty and Rust source code
- **crustydoc**: The documentation generator binary that produces documentation from Crusty source code
- **Transpiler**: A source-to-source compiler that translates code from one programming language to another
- **Source_Program**: A program written in the source language (Crusty or Rust)
- **Target_Program**: The resulting code generated by the Transpiler in the target language
- **Parser**: The component that reads and validates source syntax
- **Code_Generator**: The component that produces target code from parsed source
- **AST**: Abstract Syntax Tree representing the parsed program structure
- **Semantic_Analyzer**: The component that validates program semantics and type correctness
- **Doc_Extractor**: The component that extracts documentation comments from Crusty source code
- **Doc_Generator**: The component that generates documentation using the Linux kernel document object model
- **Rust_Parser**: The component that reads and validates Rust syntax for reverse transpilation
- **CI_Pipeline**: The continuous integration pipeline that automatically builds and tests code
- **Developer**: A programmer working on the Crusty transpiler or writing Crusty programs
- **Crusty_Repository**: The official Crusty transpiler repository at https://github.com/major0/crusty.git

## Requirements

## Development Workflow and Infrastructure

### Requirement 1: Implement CI/CD Pipeline for Automated Build and Test

**User Story:** As a transpiler developer, I want a GitHub CI/CD pipeline that automatically builds and tests all code, so that I can ensure code quality and catch regressions early.

#### Acceptance Criteria

1. THE CI_Pipeline SHALL trigger on all push events to the main branch
2. THE CI_Pipeline SHALL trigger on all pull request events
3. WHEN code is pushed, THE CI_Pipeline SHALL check out the repository code
4. WHEN code is checked out, THE CI_Pipeline SHALL set up the Rust toolchain with the latest stable version
5. WHEN the Rust toolchain is ready, THE CI_Pipeline SHALL run cargo build to compile all code
6. WHEN the build succeeds, THE CI_Pipeline SHALL run cargo test to execute all unit tests
7. WHEN the build succeeds, THE CI_Pipeline SHALL run cargo test to execute all property-based tests
8. WHEN tests complete, THE CI_Pipeline SHALL run cargo clippy to check for common mistakes and style issues
9. WHEN clippy completes, THE CI_Pipeline SHALL run cargo fmt --check to verify code formatting
10. WHEN any CI step fails, THE CI_Pipeline SHALL report the failure with detailed error messages
11. WHEN all CI steps pass, THE CI_Pipeline SHALL report success
12. THE CI_Pipeline SHALL cache Rust dependencies to speed up subsequent builds
13. THE CI_Pipeline SHALL run on multiple platforms (Linux, macOS, Windows) to ensure cross-platform compatibility
14. THE CI_Pipeline SHALL fail the build if any test fails
15. THE CI_Pipeline SHALL fail the build if clippy reports any warnings or errors
16. THE CI_Pipeline SHALL fail the build if code is not properly formatted
17. THE CI_Pipeline configuration SHALL be stored in .github/workflows/ci.yml
18. THE CI_Pipeline SHALL display build status badges in the repository README

### Requirement 2: Implement Git Commit Workflow for Task Completion

**User Story:** As a transpiler developer, I want to commit code changes after each task completion using Conventional Commits format, so that I can track progress and maintain a clear, standardized development history.

#### Acceptance Criteria

1. WHEN a task is completed, THE Developer SHALL create a git commit containing all code changes
2. WHEN creating a commit, THE Developer SHALL include updates to tasks.md marking the task as complete
3. WHEN creating a commit, THE Developer SHALL write a commit message following the Conventional Commits specification (https://www.conventionalcommits.org/)
4. THE commit message SHALL follow the format: "type(scope): subject" where type is one of feat, fix, docs, style, refactor, test, chore
5. WHEN implementing a new feature task, THE commit type SHALL be "feat"
6. WHEN fixing a bug or issue, THE commit type SHALL be "fix"
7. WHEN updating documentation, THE commit type SHALL be "docs"
8. WHEN adding or updating tests, THE commit type SHALL be "test"
9. WHEN refactoring code without changing functionality, THE commit type SHALL be "refactor"
10. WHEN performing maintenance tasks, THE commit type SHALL be "chore"
11. THE commit scope SHALL reference the task number (e.g., "feat(task-2.1): implement parser for function declarations")
12. THE commit message body SHALL include a detailed description of what was implemented
13. THE commit message body SHALL reference relevant requirements from requirements.md using the format "Validates: Requirements X.Y"
14. WHEN multiple files are changed for a task, THE Developer SHALL include all related changes in a single commit
15. THE Developer SHALL NOT commit incomplete or broken code
16. THE Developer SHALL ensure all tests pass before committing
17. WHEN a task has sub-tasks, THE Developer SHALL create separate commits for each completed sub-task
18. THE Developer SHALL push commits to the remote repository regularly to enable CI/CD validation
19. THE commit history SHALL provide a clear audit trail of feature development
20. WHEN reverting changes is necessary, THE Developer SHALL be able to identify and revert specific task commits
21. WHEN a commit introduces breaking changes, THE commit message SHALL include "BREAKING CHANGE:" in the footer

### Requirement 3: Implement Pre-Commit Hooks for Code Quality

**User Story:** As a Crusty developer, I want pre-commit hooks that automatically validate my code before committing, so that I can catch issues early and maintain code quality standards.

#### Acceptance Criteria

1. THE Crusty_Repository SHALL provide a .pre-commit-config.yaml configuration file
2. THE pre-commit configuration SHALL be compatible with the pre-commit framework (https://pre-commit.com)
3. WHEN a developer installs pre-commit hooks, THE hooks SHALL run automatically before each git commit
4. THE pre-commit hooks SHALL run crustyc syntax validation on all .crst files
5. THE pre-commit hooks SHALL run cargo fmt --check on all Rust source files
6. THE pre-commit hooks SHALL run cargo clippy on all Rust source files
7. THE pre-commit hooks SHALL run basic linting checks on Crusty source files
8. WHEN syntax errors are detected, THE pre-commit hooks SHALL prevent the commit and display error messages
9. WHEN formatting issues are detected, THE pre-commit hooks SHALL prevent the commit and suggest running cargo fmt
10. WHEN clippy warnings are detected, THE pre-commit hooks SHALL prevent the commit and display the warnings
11. THE pre-commit configuration SHALL be reusable by external Crusty projects
12. WHEN an external project references the Crusty repository (https://github.com/major0/crusty.git), THE pre-commit hooks SHALL be available for use
13. THE pre-commit configuration SHALL support running hooks on staged files only
14. THE pre-commit configuration SHALL provide a way to skip hooks when necessary (--no-verify flag)
15. THE Crusty_Repository documentation SHALL include instructions for installing and using pre-commit hooks
16. THE pre-commit hooks SHALL complete execution within a reasonable time (under 30 seconds for typical commits)
17. WHEN pre-commit hooks fail, THE error messages SHALL clearly indicate which check failed and how to fix it
18. THE pre-commit configuration SHALL be versioned and maintained alongside the compiler code

### Requirement 4: Provide MIT License

**User Story:** As a Crusty user or contributor, I want the project to be licensed under the MIT license, so that I understand my rights and obligations when using or contributing to the project.

#### Acceptance Criteria

1. THE Crusty_Repository SHALL include a LICENSE.txt file in the root directory
2. THE LICENSE.txt file SHALL contain the complete MIT License text
3. THE MIT License SHALL include the copyright notice with the project name and year
4. THE MIT License SHALL include the standard MIT License permissions and limitations
5. ALL source code files SHALL include a copyright header referencing the MIT License
6. THE README documentation SHALL clearly state that the project is licensed under the MIT License
7. THE LICENSE.txt file SHALL be included in all distribution packages
8. WHEN contributors submit code, THE contribution guidelines SHALL reference the MIT License

### Requirement 5: Support EditorConfig for Consistent Code Formatting

**User Story:** As a Crusty developer, I want EditorConfig support to ensure consistent code formatting across different editors and IDEs, so that all contributors follow the same formatting standards.

#### Acceptance Criteria

1. THE Crusty_Repository SHALL provide an .editorconfig file in the root directory
2. THE .editorconfig file SHALL be compatible with the EditorConfig specification (https://editorconfig.org/)
3. THE .editorconfig file SHALL define formatting rules for Crusty source files (.crst)
4. THE .editorconfig file SHALL define formatting rules for Rust source files (.rs)
5. THE .editorconfig file SHALL define formatting rules for TOML configuration files (.toml)
6. THE .editorconfig file SHALL define formatting rules for Markdown documentation files (.md)
7. THE .editorconfig file SHALL define formatting rules for YAML configuration files (.yml, .yaml)
8. THE .editorconfig file SHALL specify indent style (spaces or tabs)
9. THE .editorconfig file SHALL specify indent size
10. THE .editorconfig file SHALL specify line ending style (LF for Unix/Linux/macOS)
11. THE .editorconfig file SHALL specify charset (UTF-8)
12. THE .editorconfig file SHALL specify whether to trim trailing whitespace
13. THE .editorconfig file SHALL specify whether to insert final newline
14. THE Crusty_Repository documentation SHALL mention EditorConfig support
15. THE .editorconfig rules SHALL be consistent with Rust formatting conventions for .rs files
16. WHEN developers use EditorConfig-compatible editors, THE formatting rules SHALL be applied automatically

### Requirement 6: Provide Example Directory with Crusty Sources

**User Story:** As a Crusty developer, I want a comprehensive example directory with working Crusty code samples, so that I can learn the language and verify the transpiler works correctly.

#### Acceptance Criteria

1. THE Crusty_Repository SHALL include an example/ directory in the root
2. THE example/ directory SHALL contain a Cargo.toml file for building the examples
3. THE example/ directory SHALL contain a build.rs script that transpiles .crst files to Rust
4. THE example/ directory SHALL contain a src/ subdirectory with .crst source files
5. THE example/ directory SHALL include a main.crst file as the entry point
6. THE example/ directory SHALL include multiple .crst files demonstrating various Crusty language features
7. THE example .crst files SHALL demonstrate function declarations (static and non-static)
8. THE example .crst files SHALL demonstrate control flow (if/else-if/else, while, for loops, switch statements)
9. THE example .crst files SHALL demonstrate struct definitions with methods
10. THE example .crst files SHALL demonstrate type-scoped static method calls with @ prefix and -> notation
11. THE example .crst files SHALL demonstrate macro usage with double-underscore naming (__println__, __vec__, etc.)
12. THE example .crst files SHALL demonstrate #define macro definitions with double-underscore naming
13. THE example .crst files SHALL demonstrate variable declarations (const, var, let, static)
14. THE example .crst files SHALL demonstrate references and borrowing (&, &var, &mut)
15. THE example .crst files SHALL demonstrate error handling with fallible return types (Type!)
16. THE example .crst files SHALL demonstrate NULL and Option type mapping
17. THE example .crst files SHALL demonstrate #use directives for importing Rust standard library modules
18. THE example .crst files SHALL demonstrate generic types with explicit type parameters
19. THE example .crst files SHALL demonstrate attributes (#[derive(Debug)], #[test], etc.)
20. THE example .crst files SHALL demonstrate namespace declarations
21. THE build.rs script in example/ SHALL invoke crustyc with --out-dir to transpile all .crst files
22. THE build.rs script SHALL handle transpilation errors gracefully
23. WHEN cargo build is run in example/, THE build.rs script SHALL transpile all .crst files to Rust
24. WHEN cargo build is run in example/, CARGO SHALL compile the generated Rust code
25. WHEN cargo run is run in example/, THE compiled binary SHALL execute successfully
26. THE CI_Pipeline SHALL build the example/ directory as part of the build process
27. THE CI_Pipeline SHALL run cargo build in the example/ directory
28. THE CI_Pipeline SHALL run cargo test in the example/ directory if tests are present
29. THE CI_Pipeline SHALL run cargo run in the example/ directory to verify the binary executes
30. WHEN the example/ directory fails to build, THE CI_Pipeline SHALL fail the build
31. THE example/ directory SHALL serve as integration tests for the Crusty transpiler
32. THE example/ directory SHALL be kept up-to-date with new language features as they are added
33. THE example .crst files SHALL include comments explaining the Crusty syntax being demonstrated
34. THE example/ directory README SHALL explain how to build and run the examples

## Core Compiler Infrastructure

### Requirement 7: Parse Crusty Source Code

**User Story:** As a transpiler developer, I want to parse Crusty source files, so that I can validate syntax and build an internal representation for transpilation to Rust.

#### Acceptance Criteria

1. WHEN a valid Crusty source file is provided, THE Parser SHALL parse it into an AST
2. WHEN invalid syntax is encountered, THE Parser SHALL report the error location and description
3. WHEN parsing completes successfully, THE Parser SHALL produce a complete AST representing the program structure
4. THE Parser SHALL support C-like function declarations with return types specified before the function name
5. THE Parser SHALL support void return type for functions that do not return a value
6. THE Parser SHALL support function declarations with typed parameters in C-style syntax
7. THE Parser SHALL support static function declarations for module-private functions
8. THE Parser SHALL support if statements with optional else-if and else clauses
9. THE Parser SHALL support else-if chaining for multiple conditional branches
10. THE Parser SHALL support C-like control flow structures (if, while, for, return)
11. THE Parser SHALL support break statements for early loop termination
12. THE Parser SHALL support continue statements for skipping to next loop iteration
13. THE Parser SHALL support Crusty's labeled break syntax (break .label)
14. THE Parser SHALL support Crusty's labeled continue syntax (continue .label)
15. THE Parser SHALL support labeled loops (.label: loop { ... })
16. WHEN generating Rust code, THE Code_Generator SHALL translate .label: to 'label:
17. WHEN generating Rust code, THE Code_Generator SHALL translate break .label to break 'label
18. WHEN generating Rust code, THE Code_Generator SHALL translate continue .label to continue 'label
19. THE Parser SHALL support C-like variable declarations and assignments
20. THE Parser SHALL support C-like expressions including arithmetic, logical, and comparison operators
21. THE Parser SHALL support C-like struct definitions
22. THE Parser SHALL reject C union declarations as incompatible with Rust
23. THE Parser SHALL reject goto statements as incompatible with Rust
24. THE Parser SHALL reject #include directives as incompatible with Crusty's module system
25. THE Parser SHALL support #define directives for macro definitions

**Label Syntax Examples:**
```crusty
// Crusty syntax
.outer: loop {
    .inner: loop {
        if (condition) break .outer;
        continue .inner;
    }
}

// Translates to Rust
'outer: loop {
    'inner: loop {
        if condition { break 'outer; }
        continue 'inner;
    }
}
```

### Requirement 8: Validate Semantic Correctness

**User Story:** As a transpiler developer, I want to validate program semantics, so that only well-formed programs are transpiled to Rust.

#### Acceptance Criteria

1. WHEN the AST is analyzed, THE Semantic_Analyzer SHALL verify all variables are declared before use
2. WHEN the AST is analyzed, THE Semantic_Analyzer SHALL verify type compatibility for all operations
3. WHEN the AST is analyzed, THE Semantic_Analyzer SHALL verify function calls match function signatures
4. WHEN semantic errors are detected, THE Semantic_Analyzer SHALL report error locations and descriptions
5. WHEN pointer syntax is incompatible with Rust, THE Semantic_Analyzer SHALL report an error
6. WHEN all semantic checks pass, THE Semantic_Analyzer SHALL mark the AST as valid for code generation

### Requirement 9: Generate Rust Code

**User Story:** As a transpiler developer, I want to generate valid Rust code from Crusty programs, so that the output can be compiled with rustc and integrated into the Rust ecosystem.

#### Acceptance Criteria

1. WHEN a validated AST is provided, THE Code_Generator SHALL produce syntactically valid Rust code
2. WHEN generating code, THE Code_Generator SHALL preserve the semantic meaning of the Source_Program
3. WHEN generating code, THE Code_Generator SHALL translate C-like function syntax to Rust function syntax
4. WHEN a function has a non-void return type, THE Code_Generator SHALL translate it to Rust -> Type syntax
5. WHEN a function has a void return type, THE Code_Generator SHALL omit the return type annotation in Rust
6. WHEN generating code, THE Code_Generator SHALL translate C-style parameter declarations to Rust parameter syntax
7. WHEN a function is declared static, THE Code_Generator SHALL translate it to a private Rust function without pub keyword
8. WHEN a function is not declared static, THE Code_Generator SHALL translate it to a public Rust function with pub keyword
9. WHEN generating code, THE Code_Generator SHALL translate if/else-if/else chains to Rust if/else if/else syntax
10. WHEN generating code, THE Code_Generator SHALL translate break statements to Rust break statements
11. WHEN generating code, THE Code_Generator SHALL translate continue statements to Rust continue statements
12. WHEN generating code, THE Code_Generator SHALL translate C-like variable declarations to Rust let bindings
13. WHEN generating code, THE Code_Generator SHALL translate C-like control flow to Rust control flow
14. WHEN generating code, THE Code_Generator SHALL translate C-like struct definitions to Rust struct definitions
15. WHEN generating code, THE Code_Generator SHALL translate compatible pointer operations to Rust reference operations
16. THE Code_Generator SHALL format output code according to Rust style conventions

### Requirement 10: Compile Generated Rust Code

**User Story:** As a Crusty user, I want the generated Rust code to compile successfully with rustc, so that I can execute my Crusty programs and integrate them into Rust projects.

#### Acceptance Criteria

1. WHEN the Target_Program is generated, THE Transpiler SHALL invoke rustc to compile it
2. WHEN rustc compilation succeeds, THE Transpiler SHALL report success to the user
3. WHEN rustc compilation fails, THE Transpiler SHALL report the Rust compiler errors to the user
4. THE Transpiler SHALL preserve the output binary location from rustc

### Requirement 11: Report Compilation Errors

**User Story:** As a Crusty programmer, I want clear error messages, so that I can fix issues in my code.

#### Acceptance Criteria

1. WHEN syntax errors occur, THE Transpiler SHALL report the line number, column number, and error description
2. WHEN semantic errors occur, THE Transpiler SHALL report the source location and error description
3. WHEN incompatible C features are used, THE Transpiler SHALL explain why the feature is not supported
4. WHEN multiple errors exist, THE Transpiler SHALL report all errors found during parsing and semantic analysis
5. THE Transpiler SHALL format error messages in a clear, human-readable format

### Requirement 12: Handle File Input and Output

**User Story:** As a Crusty programmer, I want to transpile source files from the command line using crustyc, so that I can integrate the transpiler into my workflow and build system.

#### Acceptance Criteria

1. WHEN invoked with a source file path, THE crustyc SHALL read the file contents
2. WHEN the source file does not exist, THE crustyc SHALL report a file not found error
3. WHEN the source file cannot be read, THE crustyc SHALL report a file access error
4. WHEN compilation succeeds, THE crustyc SHALL write the Target_Program to a specified output file
5. WHERE an output file path is not specified, THE crustyc SHALL use a default output path based on the input filename
6. WHEN the output file cannot be written, THE crustyc SHALL report a file write error

### Requirement 13: Support Command-Line Options

**User Story:** As a Crusty programmer, I want to control transpiler behavior through command-line options, so that I can customize the transpilation and build process.

#### Acceptance Criteria

1. THE crustyc SHALL support -o or --output option to specify the output file path for single-file compilation
2. THE crustyc SHALL support --out-dir option to specify the output directory for multi-file compilation
3. THE crustyc SHALL support --emit option to control what gets generated (rust, binary, ast)
4. WHEN --emit=rust is specified, THE crustyc SHALL generate Rust source code only without invoking rustc
5. WHEN --emit=binary is specified or --emit is not provided, THE crustyc SHALL generate Rust code and compile it with rustc
6. WHEN --emit=ast is specified, THE crustyc SHALL output the parsed AST in a human-readable format
7. THE crustyc SHALL support -v or --verbose option for detailed compilation output
8. WHEN --verbose is specified, THE crustyc SHALL output detailed information about parsing, semantic analysis, and code generation stages
9. THE crustyc SHALL support --version option to display the compiler version
10. THE crustyc SHALL support -h or --help option to display usage information
11. THE crustyc SHALL support --no-compile option to generate Rust code without invoking rustc
12. THE crustyc SHALL support --from-lang option to specify the source language (crusty or rust)
13. WHEN multiple incompatible options are specified, THE crustyc SHALL report an error with explanation
14. THE crustyc SHALL display clear usage information when invoked with invalid options
15. WHEN --out-dir is specified, THE crustyc SHALL create the directory if it does not exist
16. WHEN --out-dir is specified with a single input file, THE crustyc SHALL write the output to that directory
17. WHEN --out-dir is specified with multiple input files or a directory, THE crustyc SHALL preserve the source directory structure in the output directory

### Requirement 14: Support Build Integration with Cargo and build.rs

**User Story:** As a Crusty programmer, I want to use standard Cargo for building projects with a build.rs script that handles Crusty-to-Rust transpilation, so that I can leverage Cargo's existing ecosystem and tooling.

#### Acceptance Criteria

1. CRUSTY projects SHALL use standard Cargo.toml files for project configuration
2. CRUSTY projects SHALL use a build.rs build script to handle Crusty-to-Rust transpilation
3. THE build.rs script SHALL invoke crustyc to transpile .crst source files to Rust
4. THE build.rs script SHALL specify an --out-dir for generated Rust files
5. THE build.rs script SHALL discover all .crst files in the src directory
6. THE build.rs script SHALL transpile each .crst file to a corresponding .rs file in the output directory
7. WHEN a .crst file is modified, THE build.rs script SHALL re-transpile only the changed files
8. THE build.rs script SHALL report transpilation errors to cargo build
9. WHEN transpilation succeeds, CARGO SHALL compile the generated Rust files normally
10. THE crustyc SHALL support --out-dir option to specify output directory for generated Rust files
11. THE crustyc SHALL support batch transpilation of multiple source files
12. THE crustyc documentation SHALL provide example build.rs scripts for common project structures
13. THE crustyc documentation SHALL explain how to configure Cargo.toml for Crusty projects
14. WHEN building a Crusty project, DEVELOPERS SHALL run standard cargo build commands
15. THE build.rs approach SHALL support all standard Cargo features (dependencies, dev-dependencies, build-dependencies, features, etc.)
16. THE crustyc SHALL NOT implement its own build system or project management
17. THE crustyc SHALL focus solely on transpilation, leaving build orchestration to Cargo

### Requirement 15: Support Multi-File Projects

**User Story:** As a Crusty programmer, I want to organize code across multiple files, so that I can build maintainable projects.

#### Acceptance Criteria

1. THE crustyc SHALL support compiling projects with multiple source files
2. THE crustyc SHALL support --out-dir option to specify where generated Rust files should be written
3. THE crustyc SHALL resolve module imports across multiple files using #use directives
4. WHEN a #use directive references a local module, THE crustyc SHALL locate the corresponding source file
5. THE crustyc SHALL support both src/main.crst for binary projects and src/lib.crst for library projects
6. THE crustyc SHALL maintain module hierarchy based on directory structure
7. WHEN generating Rust code for multi-file projects, THE Code_Generator SHALL create corresponding .rs files in the output directory
8. WHEN generating Rust code for multi-file projects, THE Code_Generator SHALL preserve the directory structure
9. THE Semantic_Analyzer SHALL resolve symbols across module boundaries
10. WHEN a module cannot be found, THE crustyc SHALL report a clear error with the expected file location
11. THE crustyc SHALL support batch mode where multiple source files can be transpiled in a single invocation
12. WHEN invoked with a directory path, THE crustyc SHALL discover and transpile all .crst files in that directory
13. THE crustyc SHALL support recursive directory traversal for discovering .crst files

### Requirement 16: Validate Program Entry Point

**User Story:** As a Crusty programmer, I want to use a C-like main() function as the entry point, so that my programs follow familiar conventions.

#### Acceptance Criteria

1. THE Parser SHALL support main() function declarations with C-like syntax
2. THE Semantic_Analyzer SHALL verify that exactly one main() function exists in the program
3. WHEN no main() function is found, THE Semantic_Analyzer SHALL report an error
4. WHEN multiple main() functions are found, THE Semantic_Analyzer SHALL report an error
5. THE Parser SHALL support main() with no parameters (void)
6. THE Parser SHALL support main() with argc/argv parameters
7. WHEN generating code, THE Code_Generator SHALL translate main() to Rust's fn main() entry point
8. WHEN main() has argc/argv parameters, THE Code_Generator SHALL translate them to appropriate Rust std.env functions

### Requirement 17: Provide Round-Trip Validation

**User Story:** As a transpiler developer, I want to validate the transpilation process, so that I can ensure correctness and bidirectional compatibility between Crusty and Rust.

#### Acceptance Criteria

1. WHEN a valid AST is generated, THE Transpiler SHALL support pretty-printing it back to Crusty syntax
2. WHEN pretty-printed Crusty code is parsed again, THE Parser SHALL produce an equivalent AST
3. THE Transpiler SHALL provide a validation mode that checks round-trip consistency

### Requirement 18: Document Unsupported C Features

**User Story:** As a Crusty programmer, I want to know which C features are unsupported, so that I can write compatible code.

#### Acceptance Criteria

1. THE Transpiler SHALL maintain a list of unsupported C features
2. WHEN an unsupported feature is encountered, THE Transpiler SHALL reference the feature documentation
3. THE Transpiler SHALL document that C unions are not supported
4. THE Transpiler SHALL document that goto statements are NOT supported
5. THE Transpiler SHALL document which pointer operations are not Rust-compatible
6. THE Transpiler SHALL document that #include directives are not supported
7. THE Transpiler SHALL document that #define macros are supported for macro definitions with double-underscore prefix and suffix naming convention and translate to Rust macro_rules!

### Requirement 19: Provide build.rs Integration Example

**User Story:** As a Crusty programmer, I want a reference build.rs script that handles Crusty transpilation, so that I can easily integrate Crusty into my Cargo projects.

#### Acceptance Criteria

1. THE crustyc documentation SHALL provide a complete example build.rs script
2. THE example build.rs script SHALL discover all .crst files in the src directory
3. THE example build.rs script SHALL invoke crustyc with --out-dir to transpile sources
4. THE example build.rs script SHALL handle transpilation errors and report them to cargo
5. THE example build.rs script SHALL use cargo:rerun-if-changed directives to track .crst file dependencies
6. THE example build.rs script SHALL create the output directory if it does not exist
7. THE example build.rs script SHALL preserve the directory structure when transpiling
8. THE example build.rs script SHALL support both library and binary project structures
9. THE crustyc documentation SHALL explain how to configure Cargo.toml to use the build script
10. THE crustyc documentation SHALL explain how to add crustyc as a build-dependency
11. THE example build.rs script SHALL be simple enough for developers to customize for their needs
12. THE example build.rs script SHALL handle incremental builds efficiently

## Type System

### Requirement 20: Support Core C-like Type System

**User Story:** As a Crusty programmer, I want to use familiar C types, so that I can write code with minimal learning curve.

#### Acceptance Criteria

1. THE Parser SHALL support integer types (int, i32, i64, u32, u64)
2. THE Parser SHALL support floating-point types (float, f32, f64)
3. THE Parser SHALL support boolean type (bool)
4. THE Parser SHALL support character type (char)
5. THE Parser SHALL support string literals
6. THE Parser SHALL support array types with fixed sizes
7. THE Parser SHALL support pointer types with Rust-compatible semantics
8. THE Parser SHALL support struct types
9. THE Semantic_Analyzer SHALL enforce type compatibility rules consistent with Rust

### Requirement 21: Support Tuple Types

**User Story:** As a Crusty programmer, I want to use tuple types for grouping multiple values, so that I can work with Rust APIs that use tuples.

#### Acceptance Criteria

1. THE Parser SHALL support tuple type syntax (Type1, Type2, Type3)
2. THE Parser SHALL support tuple literals ((value1, value2, value3))
3. THE Parser SHALL support empty tuples (unit type) ()
4. THE Parser SHALL support tuple indexing with .0, .1, .2 syntax
5. THE Parser SHALL support tuples in function parameters and return types
6. THE Parser SHALL support nested tuples
7. WHEN generating Rust code, THE Code_Generator SHALL pass tuple syntax directly to Rust unchanged
8. THE Semantic_Analyzer SHALL verify tuple element access is within bounds
9. THE Semantic_Analyzer SHALL enforce type compatibility for tuple elements
10. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve tuple syntax in Crusty

### Requirement 22: Support Array and Collection Literals

**User Story:** As a Crusty programmer, I want to use array literals and collection initialization syntax, so that I can create arrays and collections easily.

#### Acceptance Criteria

1. THE Parser SHALL support array literal syntax [value1, value2, value3]
2. THE Parser SHALL support array initialization syntax [value; count] for repeated values
3. THE Parser SHALL support empty array literals []
4. WHEN generating Rust code, THE Code_Generator SHALL pass array literal syntax directly to Rust unchanged
5. THE Semantic_Analyzer SHALL verify all array literal elements have compatible types
6. THE Semantic_Analyzer SHALL verify array initialization count is a compile-time constant
7. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve array literal syntax in Crusty

### Requirement 23: Support Struct Methods and Implementation Blocks

**User Story:** As a Crusty programmer, I want to define methods on structs using C++-style syntax, so that I can write object-oriented code.

#### Acceptance Criteria

1. THE Parser SHALL support C++-style method definitions within struct declarations
2. THE Parser SHALL support methods with self parameter for instance methods
3. THE Parser SHALL support methods with &self parameter for immutable instance methods
4. THE Parser SHALL support methods with &var self or &mut self parameter for mutable instance methods
5. THE Parser SHALL support static methods (associated functions) without self parameter
6. THE Parser SHALL support method calls with dot notation (obj.method())
7. THE Parser SHALL support static method calls with @ prefix and arrow notation (@Type->method())
8. THE Parser SHALL require @ prefix for all type-scoped static method calls
9. WHEN generating Rust code, THE Code_Generator SHALL translate struct methods to Rust impl blocks
10. WHEN generating Rust code, THE Code_Generator SHALL translate self to Rust self
11. WHEN generating Rust code, THE Code_Generator SHALL translate &self to Rust &self
12. WHEN generating Rust code, THE Code_Generator SHALL translate &var self and &mut self to Rust &mut self
13. WHEN generating Rust code, THE Code_Generator SHALL translate @Type->method() to Rust Type::method()
14. THE Semantic_Analyzer SHALL verify method calls are made on appropriate types
15. THE Semantic_Analyzer SHALL verify self is only used in instance methods
16. THE Semantic_Analyzer SHALL require @ prefix for type-scoped static method calls
17. THE Semantic_Analyzer SHALL reject type-scoped calls without @ prefix
18. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust impl blocks to Crusty struct methods
19. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust Type::method() to Crusty @Type->method()

### Requirement 24: Support Traits as C-Style VTable Structs

**User Story:** As a Crusty programmer, I want to define and implement traits using C-style vtable structs, so that I can define shared behavior across types with familiar C patterns.

#### Acceptance Criteria

1. THE Parser SHALL support typedef struct definitions for vtable structs containing function pointers
2. THE Parser SHALL support function pointer fields in vtable structs with void *self as first parameter
3. THE Parser SHALL support naming convention of VTable suffix for trait vtable structs (e.g., DrawableVTable)
4. THE Parser SHALL recognize vtable struct patterns where function pointers take void *self or typed self pointers
5. WHEN a vtable struct is defined, THE Semantic_Analyzer SHALL identify it as a trait definition
6. WHEN generating Rust code, THE Code_Generator SHALL translate vtable structs to Rust trait definitions
7. WHEN generating Rust code, THE Code_Generator SHALL translate function pointer fields to trait method signatures
8. WHEN generating Rust code, THE Code_Generator SHALL translate void *self parameters to Rust &self or &mut self based on method semantics
9. WHEN a struct contains a vtable struct field, THE Code_Generator SHALL generate appropriate Rust trait implementation
10. WHEN a struct contains a vtable struct pointer field, THE Code_Generator SHALL generate trait object usage (dyn Trait)
11. THE Semantic_Analyzer SHALL verify vtable function pointer signatures are consistent
12. THE Semantic_Analyzer SHALL verify that structs using vtables provide implementations for all function pointers
13. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust trait definitions to C-style vtable structs
14. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust trait implementations to vtable initialization code
15. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust trait objects (dyn Trait) to vtable pointer patterns

### Requirement 25: Support Using Rust Macros

**User Story:** As a Crusty programmer, I want to use Rust's standard macros with double-underscore prefix and suffix naming convention, so that I can leverage existing Rust functionality for common tasks with clear macro identification.

#### Acceptance Criteria

1. THE Parser SHALL support Crusty macro invocation syntax WITHOUT ! suffix (__macro_name__(args), __macro_name__[args], __macro_name__{args})
2. THE Parser SHALL require macros to be denoted by double-underscores as prefix and suffix of the macro name (e.g., __println__, __vec__, __assert__, __panic__)
3. THE Parser SHALL support common Rust macros with double-underscore naming (__println__(...), __print__(...), __format__(...), __vec__[...], __assert__(...), __panic__(...), etc.)
4. THE Parser SHALL support macro invocations in expression contexts
5. THE Parser SHALL support macro invocations in statement contexts
6. THE Parser SHALL use double-underscore pattern exclusively for macros, while @ prefix is exclusively for type-scoped calls
7. WHEN generating Rust code, THE Code_Generator SHALL translate __macro_name__ to Rust macro_name! (removing the double-underscore prefix and suffix, adding !)
8. THE Semantic_Analyzer SHALL validate macro arguments where possible
9. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust macro_name! to Crusty __macro_name__ (adding double-underscore prefix and suffix, removing !)
10. THE Semantic_Analyzer SHALL prohibit function definitions with leading AND trailing double-underscores (reserved for macros)
11. WHEN a function is defined with double-underscore pattern, THE Semantic_Analyzer SHALL report error: "Function names cannot use double-underscore pattern (reserved for macros)"

### Requirement 26: Support Defining Macros with #define

**User Story:** As a Crusty programmer, I want to define macros using #define syntax with double-underscore naming convention, so that I can create reusable code patterns that translate to Rust macro_rules!

#### Acceptance Criteria

1. THE Parser SHALL support #define directive for macro definitions
2. THE Parser SHALL require macro names to have double-underscores as prefix and suffix (e.g., __MACRO_NAME__)
3. THE Parser SHALL prohibit #define from defining macros without double-underscore prefix and suffix characters
4. THE Parser SHALL support #define with macro name and parameter list (#define __MACRO_NAME__(param1, param2) body)
5. THE Parser SHALL support #define with macro name only for simple macros (#define __MACRO_NAME__ body)
6. THE Parser SHALL support macro bodies containing expressions, statements, and code blocks
7. THE Parser SHALL support macro parameters in the macro body
8. THE Parser SHALL parse the macro body as a token sequence without full semantic analysis
9. WHEN generating Rust code, THE Code_Generator SHALL translate #define macros to Rust macro_rules! definitions
10. WHEN generating Rust code, THE Code_Generator SHALL remove double-underscore prefix and suffix from macro names (e.g., __MACRO_NAME__ becomes macro_name)
11. WHEN generating Rust code, THE Code_Generator SHALL translate macro parameters to Rust macro pattern variables ($param:expr)
12. WHEN generating Rust code, THE Code_Generator SHALL wrap the macro body in appropriate Rust macro syntax
13. THE Semantic_Analyzer SHALL validate that #define macros have valid syntax
14. THE Semantic_Analyzer SHALL verify that macro names follow the double-underscore prefix and suffix convention
15. THE Semantic_Analyzer SHALL verify that macro parameters are used consistently in the macro body
16. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust macro_rules! definitions to Crusty #define syntax with double-underscore prefix and suffix
17. WHEN a Rust macro_rules! is too complex to represent as #define, THE Transpiler SHALL preserve it as __rust__! { macro_rules! ... }

### Requirement 27: Support Attributes

**User Story:** As a Crusty programmer, I want to use attributes to add metadata to code elements, so that I can control transpiler behavior and derive common traits.

#### Acceptance Criteria

1. THE Parser SHALL support attribute syntax #[attribute_name]
2. THE Parser SHALL support attributes with arguments #[attribute(arg1, arg2)]
3. THE Parser SHALL support derive attribute for automatic trait implementation #[derive(Debug, Clone, Copy)]
4. THE Parser SHALL support test attribute for unit tests #[test]
5. THE Parser SHALL support cfg attribute for conditional compilation #[cfg(target_os = "linux")]
6. THE Parser SHALL support attributes on structs, enums, functions, and fields
7. THE Parser SHALL support multiple attributes on a single item
8. WHEN generating Rust code, THE Code_Generator SHALL pass attributes directly to Rust unchanged
9. THE Semantic_Analyzer SHALL validate attribute syntax and known attribute names
10. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve attributes in Crusty

### Requirement 28: Support Rust Slice and Range Syntax

**User Story:** As a Crusty programmer, I want to use Rust's slice and range syntax transparently, so that I can work with ranges and array slices naturally.

#### Acceptance Criteria

1. THE Parser SHALL support Rust's range syntax (start..end for exclusive ranges)
2. THE Parser SHALL support Rust's inclusive range syntax (start..=end)
3. THE Parser SHALL support open-ended ranges (start.., ..end, ..)
4. THE Parser SHALL support range expressions in for loops
5. THE Parser SHALL support range expressions for array/slice indexing (arr[start..end])
6. THE Parser SHALL support slice type syntax (&[Type])
7. THE Parser SHALL support mutable slice type syntax (&var [Type] or &mut [Type])
8. WHEN generating Rust code, THE Code_Generator SHALL pass range syntax directly to Rust unchanged
9. WHEN generating Rust code, THE Code_Generator SHALL pass slice syntax directly to Rust unchanged
10. THE Semantic_Analyzer SHALL verify that range bounds are valid integer expressions
11. THE Semantic_Analyzer SHALL verify that slice operations are performed on valid array or slice types
12. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve range and slice syntax unchanged in Crusty

### Requirement 29: Support Type Casting

**User Story:** As a Crusty programmer, I want to cast between types using familiar C syntax, so that I can perform type conversions with minimal learning curve.

#### Acceptance Criteria

1. THE Parser SHALL support C-style cast syntax ((type)expression)
2. THE Parser SHALL support casts between numeric types
3. THE Parser SHALL support casts between pointer types where safe
4. THE Parser SHALL support casts from pointers to integers and vice versa where Rust-compatible
5. WHEN generating Rust code, THE Code_Generator SHALL translate C-style casts to Rust as operator
6. WHEN a cast is unsafe or incompatible with Rust, THE Semantic_Analyzer SHALL report an error
7. THE Semantic_Analyzer SHALL verify that casts maintain type safety according to Rust rules
8. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust as operator to C-style cast syntax

### Requirement 30: Support Sizeof Operator

**User Story:** As a Crusty programmer, I want to use the sizeof operator to determine type and variable sizes, so that I can write size-aware code.

#### Acceptance Criteria

1. THE Parser SHALL support sizeof operator with C-style syntax (sizeof(type) and sizeof(expression))
2. THE Parser SHALL support sizeof for all primitive types
3. THE Parser SHALL support sizeof for struct types
4. THE Parser SHALL support sizeof for array types
5. THE Parser SHALL support sizeof for pointer types
6. WHEN generating Rust code, THE Code_Generator SHALL translate sizeof to std.mem.size_of or std.mem.size_of_val
7. THE Semantic_Analyzer SHALL verify that sizeof is used with valid types or expressions
8. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate std.mem.size_of to sizeof operator

### Requirement 31: Support C-Style Operators

**User Story:** As a Crusty programmer, I want to use standard C operators with familiar behavior, so that I can write expressions naturally.

#### Acceptance Criteria

1. THE Parser SHALL support all standard C arithmetic operators (+, -, *, /, %)
2. THE Parser SHALL support all standard C comparison operators (==, !=, <, >, <=, >=)
3. THE Parser SHALL support all standard C logical operators (&&, ||, !)
4. THE Parser SHALL support all standard C bitwise operators (&, |, ^, ~, <<, >>)
5. THE Parser SHALL support C assignment operators (=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=)
6. THE Parser SHALL support C prefix increment and decrement operators (++i, --i)
7. THE Parser SHALL support C postfix increment and decrement operators (i++, i--)
8. WHEN a prefix increment/decrement is used, THE Semantic_Analyzer SHALL verify it increments/decrements before returning the value
9. WHEN a postfix increment/decrement is used, THE Semantic_Analyzer SHALL verify it returns the original value before incrementing/decrementing
10. WHEN generating Rust code for prefix increment (++i), THE Code_Generator SHALL translate to (i += 1; i) or equivalent
11. WHEN generating Rust code for postfix increment (i++), THE Code_Generator SHALL translate to ({ let tmp = i; i += 1; tmp }) or equivalent
12. WHEN generating Rust code for prefix decrement (--i), THE Code_Generator SHALL translate to (i -= 1; i) or equivalent
13. WHEN generating Rust code for postfix decrement (i--), THE Code_Generator SHALL translate to ({ let tmp = i; i -= 1; tmp }) or equivalent
14. THE Parser SHALL support C ternary conditional operator (? :)
15. THE Parser SHALL support C member access operators (., ->)
16. THE Parser SHALL support C array subscript operator ([])
17. THE Parser SHALL support C address-of operator (&)
18. THE Parser SHALL support C dereference operator (*)
19. THE Semantic_Analyzer SHALL enforce C operator precedence and associativity rules
20. WHEN generating Rust code, THE Code_Generator SHALL translate C operators to equivalent Rust operators
21. THE Semantic_Analyzer SHALL verify that operators are used with compatible types

### Requirement 32: Support Pointer Arithmetic with Rust Constraints

**User Story:** As a Crusty programmer, I want to perform pointer arithmetic within Rust's safety constraints, so that I can work with memory safely.

#### Acceptance Criteria

1. THE Parser SHALL support pointer arithmetic operations (pointer + offset, pointer - offset)
2. THE Parser SHALL support pointer difference operations (pointer - pointer)
3. THE Semantic_Analyzer SHALL enforce Rust's pointer arithmetic safety rules
4. THE Semantic_Analyzer SHALL require unsafe context for raw pointer arithmetic
5. WHEN generating Rust code, THE Code_Generator SHALL translate safe pointer operations to slice indexing where possible
6. WHEN generating Rust code, THE Code_Generator SHALL translate unsafe pointer arithmetic to Rust unsafe blocks with offset operations
7. THE Semantic_Analyzer SHALL verify that pointer arithmetic maintains memory safety
8. THE Semantic_Analyzer SHALL report errors for pointer arithmetic that violates Rust's safety guarantees

### Requirement 33: Support Type Aliases with Typedef

**User Story:** As a Crusty programmer, I want to create type aliases using typedef, so that I can define meaningful names for complex types.

#### Acceptance Criteria

1. THE Parser SHALL support typedef declarations with C-style syntax (typedef existing_type new_name;)
2. THE Parser SHALL support typedef for primitive types (typedef int MyInt;)
3. THE Parser SHALL support typedef for struct types (typedef struct Point { int x; int y; } Point;)
4. THE Parser SHALL support typedef for pointer types (typedef int* IntPtr;)
5. THE Parser SHALL support typedef for array types (typedef int IntArray[10];)
6. THE Parser SHALL support typedef for function pointer types
7. WHEN a typedef is encountered, THE Semantic_Analyzer SHALL register the new type name in the symbol table
8. WHEN a typedef name is used, THE Semantic_Analyzer SHALL resolve it to the underlying type
9. WHEN generating Rust code, THE Code_Generator SHALL translate typedef to Rust type alias (type NewName = ExistingType;)
10. WHEN generating Rust code for struct typedef, THE Code_Generator SHALL create both the struct definition and type alias if needed
11. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust type aliases to Crusty typedef declarations
12. THE Semantic_Analyzer SHALL verify that typedef names do not conflict with existing type names

### Requirement 34: Support C-Style Enum Declarations

**User Story:** As a Crusty programmer, I want to declare enums using C/C++/Go style syntax, so that I can define enumerated types with familiar syntax.

#### Acceptance Criteria

1. THE Parser SHALL support enum declarations with C-style syntax (enum Name { Value1, Value2 })
2. THE Parser SHALL support enum variants with explicit integer values (enum Name { Value1 = 0, Value2 = 5 })
3. THE Parser SHALL support enum variants with automatic value assignment (incrementing from previous value)
4. WHEN an enum variant has no explicit value, THE Parser SHALL assign it the value of the previous variant plus one
5. WHEN the first enum variant has no explicit value, THE Parser SHALL assign it the value zero
6. THE Semantic_Analyzer SHALL verify that enum values are unique within the enum
7. THE Semantic_Analyzer SHALL verify that enum values are valid integer constants
8. WHEN generating Rust code, THE Code_Generator SHALL translate C-style enums to Rust enums with integer discriminants
9. WHEN generating Rust code, THE Code_Generator SHALL add appropriate derive attributes for Rust enum compatibility
10. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate simple Rust enums to Crusty C-style enums
11. WHEN reverse transpiling complex Rust enums with data, THE Transpiler SHALL report an error indicating the feature is not supported in Crusty

### Requirement 35: Support String Types

**User Story:** As a Crusty programmer, I want to use both Rust string types and C-style character arrays, so that I can choose between safety and C compatibility.

#### Acceptance Criteria

1. THE Parser SHALL support Rust's String type directly in Crusty syntax
2. THE Parser SHALL support Rust's &str type directly in Crusty syntax
3. THE Parser SHALL support char array declarations for C-style strings (char[])
4. THE Parser SHALL support string literals with double quotes ("text")
5. WHEN a string literal is assigned to a String or &str variable, THE Code_Generator SHALL preserve the Rust string type
6. WHEN a string literal is assigned to a char array, THE Code_Generator SHALL generate appropriate conversion code
7. WHEN generating Rust code, THE Code_Generator SHALL preserve String and &str types unchanged
8. WHEN generating Rust code, THE Code_Generator SHALL translate char arrays to appropriate Rust array or CString types
9. THE Semantic_Analyzer SHALL enforce type compatibility between string types
10. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve String and &str types in Crusty
11. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate CString or [u8] types to char arrays where appropriate

### Requirement 36: Support NULL and Option Type Mapping

**User Story:** As a Crusty programmer, I want to use NULL for nullable pointers, so that I can write familiar C-style code that maps safely to Rust's Option type.

#### Acceptance Criteria

1. THE Parser SHALL support the NULL keyword for nullable pointer values
2. THE Parser SHALL support nullable pointer type declarations
3. WHEN NULL is used with non-pointer types, THE Semantic_Analyzer SHALL report an error
4. WHEN generating Rust code, THE Code_Generator SHALL translate NULL to @Option->None
5. WHEN generating Rust code, THE Code_Generator SHALL translate nullable pointer types to Option<&T> or Option<&mut T>
6. WHEN generating Rust code, THE Code_Generator SHALL translate NULL comparisons (ptr == NULL) to Option is_none() checks
7. WHEN generating Rust code, THE Code_Generator SHALL translate non-NULL comparisons (ptr != NULL) to Option is_some() checks
8. WHEN generating Rust code, THE Code_Generator SHALL translate NULL assignments to @Option->None assignments
9. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Option::None to NULL
10. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Option<&T> types to nullable pointer types
11. THE Semantic_Analyzer SHALL enforce that NULL is only used in contexts where Option types are valid

## Variables and Memory Management

### Requirement 37: Support Variable Mutability

**User Story:** As a Crusty programmer, I want explicit control over variable mutability with clear keywords, so that I can write safe code with clear intent.

#### Acceptance Criteria

1. THE Parser SHALL support const keyword for compile-time constant declarations
2. THE Parser SHALL support var keyword to declare mutable variables
3. THE Parser SHALL support let keyword to declare immutable variables
4. THE Parser SHALL support static keyword for static variables with C/Rust semantics
5. WHEN no keyword is specified for a variable declaration, THE Parser SHALL default to let (immutable)
6. WHEN a const declaration is encountered, THE Semantic_Analyzer SHALL verify the value is a compile-time constant
7. WHEN a const declaration is encountered, THE Code_Generator SHALL translate it to Rust const declaration
8. WHEN a var declaration is encountered, THE Code_Generator SHALL translate it to Rust let mut binding
9. WHEN a let declaration is encountered, THE Code_Generator SHALL translate it to Rust let binding
10. WHEN a static declaration is encountered, THE Code_Generator SHALL translate it to Rust static declaration
11. THE Semantic_Analyzer SHALL verify that const declarations have compile-time constant values
12. THE Semantic_Analyzer SHALL verify that let (immutable) variables are not reassigned
13. THE Semantic_Analyzer SHALL verify that static variables follow Rust's static variable rules
14. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust const to Crusty const
15. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust let mut to Crusty var
16. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust let to Crusty let
17. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust static to Crusty static

### Requirement 38: Support References, Borrowing, and Lifetimes

**User Story:** As a Crusty programmer, I want to use clear reference syntax for safe memory access with lifetime tracking, so that I can leverage Rust's ownership system with intuitive syntax.

#### Acceptance Criteria

1. THE Parser SHALL support & syntax for immutable references (immutable borrows)
2. THE Parser SHALL support &var syntax for mutable references (mutable borrows)
3. THE Parser SHALL support &mut as an alternative to &var for mutable references
4. THE Parser SHALL support reference syntax in variable declarations, function parameters, and return types
5. THE Parser SHALL support dereferencing with * operator
6. THE Parser SHALL use reference syntax in function parameters and return types to indicate lifetimes
7. WHEN a function parameter uses & or &var, THE Semantic_Analyzer SHALL infer the lifetime relationship between parameters and return values
8. WHEN a function returns a reference, THE Semantic_Analyzer SHALL verify the reference is tied to an input parameter's lifetime
9. WHEN multiple reference parameters exist, THE Semantic_Analyzer SHALL infer lifetime relationships based on which parameters the return value derives from
10. WHEN generating Rust code, THE Code_Generator SHALL translate & to Rust immutable references (&)
11. WHEN generating Rust code, THE Code_Generator SHALL translate &var and &mut to Rust mutable references (&mut)
12. WHEN generating Rust code, THE Code_Generator SHALL add explicit Rust lifetime annotations where necessary based on inferred relationships
13. THE Semantic_Analyzer SHALL enforce Rust's borrowing rules (one mutable reference OR multiple immutable references)
14. THE Semantic_Analyzer SHALL verify that &var (mutable references) are only created from var (mutable) variables
15. THE Semantic_Analyzer SHALL verify that references do not outlive their referents
16. THE Semantic_Analyzer SHALL allow & (immutable references) from both let and var variables
17. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust & to Crusty &
18. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust &mut to Crusty &var or &mut
19. WHEN reverse transpiling from Rust, THE Code_Generator SHALL omit explicit lifetime annotations and rely on Crusty's inference

### Requirement 39: Use Rust Standard Library Directly

**User Story:** As a Crusty programmer, I want to use Rust's standard library directly, so that I can leverage existing Rust functionality and maintain full ecosystem compatibility without reimplementation.

#### Acceptance Criteria

1. CRUSTY SHALL NOT provide its own standard library implementation
2. THE crustyc SHALL rely entirely on Rust's standard library (std) for all standard functionality
3. CRUSTY programs SHALL have full access to the Rust ecosystem through direct imports
4. WHEN Crusty code uses #use directives, THE Code_Generator SHALL translate them directly to Rust use statements
5. THE Parser SHALL support importing any Rust standard library module via #use (e.g., #use std.collections.HashMap)
6. THE Parser SHALL support importing Rust types, functions, and traits from std modules
7. WHEN generating code, THE Code_Generator SHALL preserve all Rust std module references unchanged
8. THE Semantic_Analyzer SHALL validate that imported Rust std types and functions are used correctly
9. THE crustyc documentation SHALL reference Rust's standard library documentation for available functionality
10. WHEN a Crusty programmer needs I/O functionality, THEY SHALL use std.io via #use std.io
11. WHEN a Crusty programmer needs collections, THEY SHALL use std.collections via #use std.collections
12. WHEN a Crusty programmer needs file operations, THEY SHALL use std.fs via #use std.fs
13. WHEN a Crusty programmer needs string operations, THEY SHALL use Rust's String and &str types directly
14. WHEN a Crusty programmer needs memory allocation, THEY SHALL use Rust's Box, Rc, Arc, Vec types via #use std.boxed, std.rc, std.sync, std.vec
15. THE crustyc SHALL NOT wrap, abstract, or modify Rust standard library functionality
16. CRUSTY projects SHALL be able to depend on any Rust crate from crates.io
17. CRUSTY projects SHALL be able to publish crates that native Rust projects can use
18. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve all std module imports as Crusty #use directives

### Requirement 40: Support Rust Ecosystem Integration

**User Story:** As a Crusty programmer, I want my Crusty projects to fully integrate with the Rust ecosystem, so that I can use existing Rust crates and create crates that Rust projects can depend on.

#### Acceptance Criteria

1. CRUSTY projects SHALL be able to add any Rust crate as a dependency in Cargo.toml
2. CRUSTY code SHALL be able to import and use types, functions, and traits from external Rust crates
3. WHEN a Crusty project is built, THE generated Rust code SHALL compile into a standard Rust crate
4. CRUSTY library projects SHALL produce .rlib files that native Rust projects can link against
5. CRUSTY binary projects SHALL produce executables identical to those produced by native Rust
6. THE crustyc documentation SHALL explain how to configure Cargo.toml for Crusty projects
7. THE crustyc documentation SHALL explain how to use external Rust crates in Crusty code
8. THE crustyc documentation SHALL explain how to create Crusty libraries that Rust projects can use
9. CRUSTY projects SHALL support all Cargo features (workspaces, features, build scripts, etc.)
10. WHEN a Crusty library is published to crates.io, RUST projects SHALL be able to depend on it
11. THE generated Rust code SHALL maintain API compatibility with the Crusty source
12. CRUSTY projects SHALL be able to implement Rust traits from external crates
13. CRUSTY projects SHALL be able to use Rust procedural macros from external crates
14. THE crustyc SHALL NOT introduce any runtime dependencies beyond what Rust requires
15. CRUSTY code SHALL have the same performance characteristics as equivalent Rust code

### Requirement 41: Support Generic Types with Explicit Type Parameters

**User Story:** As a Crusty programmer, I want to use Rust's generic types with both angle bracket and parentheses/brackets syntax, so that I can work with collections and other generic types from the standard library with familiar C-like syntax for explicit type parameters.

#### Acceptance Criteria

**Basic Generic Type Support:**

1. THE Parser SHALL support generic type syntax with angle brackets (Type<T>)
2. THE Parser SHALL support generic types with multiple type parameters (HashMap<K, V>)
3. THE Parser SHALL support nested generic types (Vec<Option<i32>>)
4. THE Parser SHALL support using generic Rust standard library types (Vec<T>, Option<T>, Result<T,E>, HashMap<K,V>, etc.)
5. THE Parser SHALL support generic type parameters in function signatures
6. THE Parser SHALL support generic type parameters in struct definitions
7. WHEN generating Rust code, THE Code_Generator SHALL pass angle bracket generic type syntax directly to Rust unchanged
8. THE Semantic_Analyzer SHALL verify that generic type parameters are properly specified
9. THE Semantic_Analyzer SHALL verify that generic types are used with compatible type arguments

**Explicit Generic Type Parameters with Parentheses and Brackets:**

10. THE Parser SHALL support explicit generic type parameters using parentheses syntax (@Type(T))
11. THE Parser SHALL support nested generic type parameters using alternating parentheses and brackets (@Type(Inner[T]))
12. THE Parser SHALL support multiple type parameters separated by commas (@Type(T1, T2))
13. THE Parser SHALL require @ prefix for all type-scoped calls with or without explicit generic parameters
14. THE Parser SHALL support omitting generic parameters when types can be fully inferred (@Type->method())
15. THE Parser SHALL use arrow notation (->) to separate type names from method calls
16. WHEN explicit generic parameters are specified, THE Parser SHALL use parentheses for the outermost level
17. WHEN nested generic parameters are specified, THE Parser SHALL alternate between parentheses and brackets for each nesting level
18. WHEN generating Rust code, THE Code_Generator SHALL translate parentheses/brackets syntax to Rust's angle bracket turbofish syntax (<>)
19. WHEN generating Rust code, THE Code_Generator SHALL translate @Type(T)->method() to Type::<T>::method()
20. WHEN generating Rust code, THE Code_Generator SHALL translate @Type(Inner[T])->method() to Type::<Inner<T>>::method()
21. WHEN generating Rust code, THE Code_Generator SHALL translate @Type(T1, T2)->method() to Type::<T1, T2>::method()
22. WHEN generic parameters are omitted, THE Code_Generator SHALL omit the turbofish syntax and rely on Rust's type inference
23. THE Semantic_Analyzer SHALL verify that parentheses and brackets alternate correctly in nested generics
24. THE Semantic_Analyzer SHALL verify that the number of type parameters matches the generic type definition
25. THE Semantic_Analyzer SHALL reject type-scoped calls without @ prefix

**Reverse Transpilation:**

26. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve angle bracket generic type syntax in Crusty
27. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust turbofish syntax (Type::<T>) to Crusty parentheses syntax (@Type(T))
28. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate nested angle brackets to alternating parentheses and brackets
29. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust Type::method() to Crusty @Type->method()

**Syntax Examples:**

```crusty
// Type-scoped calls always require @ prefix with -> notation
let opt = @Option->None;          // Type inferred from context
let v = @Vec->new();               // Type inferred from usage

// Explicit type parameters with required @ prefix
let opt = @Option(Result[String, std.io.Error])->None;
let v = @Vec(i32)->new();

// Deep nesting with alternating parentheses and brackets
let complex = @Option(Inner[Type(T), std.io.Error])->None;
// Translates to: Option::<Inner<Type<T>, std::io::Error>>::None

// Nested type paths work naturally with -> notation
let result = @Foo->Bar.boo();  // Translates to: Foo::Bar.boo()

// @ is ALWAYS required for type-scoped calls
// Type(i32)->new()  is INVALID - missing @
// Type->method()    is INVALID - missing @

// Angle bracket syntax for type declarations
let map: HashMap<String, i32> = @HashMap->new();
fn process<T>(value: T) -> Option<T> { ... }

// Rust equivalent translations:
// @Option(Result[String, std.io.Error])->None  Option::<Result<String, std::io::Error>>::None
// @Vec(i32)->new()  Vec::<i32>::new()
// @Option(Inner[Type(T), std.io.Error])->None  Option::<Inner<Type<T>, std::io::Error>>::None
// @Option->None  Option::None (no turbofish, relies on inference)
// @Vec->new()  Vec::new() (no turbofish, relies on inference)
// @Type->new()  Type::new() (type-scoped call, no turbofish)
// @Foo->Bar.boo()  Foo::Bar.boo() (nested type path)
```

**Nesting Rules for Parentheses/Brackets:**
- Level 0 (outermost): Parentheses `()`
- Level 1: Brackets `[]`
- Level 2: Parentheses `()`
- Level 3: Brackets `[]`
- Pattern continues alternating for deeper nesting
- Example: `@A(B[C(D[E(F)])])`  `A::<B<C<D<E<F>>>>>`

### Requirement 42: Support C-Style Struct Initialization

**User Story:** As a Crusty programmer, I want to initialize structs using C-style designated initializer syntax, so that I can create struct instances with familiar syntax.

#### Acceptance Criteria

1. THE Parser SHALL support C99 designated initializer syntax (.field = value)
2. THE Parser SHALL support struct initialization with designated initializers (struct Point p = { .x = 10, .y = 20 };)
3. THE Parser SHALL support partial struct initialization with designated initializers
4. THE Parser SHALL support nested struct initialization
5. THE Parser SHALL allow designated initializers in any order
6. WHEN generating Rust code, THE Code_Generator SHALL translate designated initializers to Rust struct literal syntax (Point { x: 10, y: 20 })
7. THE Semantic_Analyzer SHALL verify that all non-optional struct fields are initialized
8. THE Semantic_Analyzer SHALL verify that initialized fields exist in the struct definition
9. THE Semantic_Analyzer SHALL verify that field values match the field types
10. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust struct literals to C-style designated initializers

### Requirement 43: Support Type Inference with Auto Keyword

**User Story:** As a Crusty programmer, I want to use the auto keyword for type inference, so that I can let the Rust compiler infer types automatically.

#### Acceptance Criteria

1. THE Parser SHALL support the auto keyword for variable type declarations
2. THE Parser SHALL allow auto in variable declarations (auto x = 5;)
3. THE Parser SHALL allow auto in function return types where Rust supports type inference
4. WHEN generating Rust code, THE Code_Generator SHALL omit explicit type annotations for auto declarations
5. WHEN generating Rust code, THE Code_Generator SHALL rely on Rust's type inference to determine the actual type
6. THE Semantic_Analyzer SHALL verify that auto is only used where Rust's type inference can determine the type
7. WHEN reverse transpiling from Rust, THE Code_Generator SHALL use auto for variables where explicit types are not specified

### Requirement 44: Support Extern C Declarations for FFI

**User Story:** As a Crusty programmer, I want to declare extern "C" functions for FFI, so that I can interface with C libraries and system calls.

#### Acceptance Criteria

1. THE Parser SHALL support extern "C" block syntax (extern "C" { ... })
2. THE Parser SHALL support extern "C" function declarations within extern blocks
3. THE Parser SHALL support extern "C" on individual function declarations
4. THE Parser SHALL support function declarations with C calling convention
5. THE Parser SHALL support linking to external C libraries
6. WHEN generating Rust code, THE Code_Generator SHALL pass extern "C" blocks directly to Rust unchanged
7. WHEN generating Rust code, THE Code_Generator SHALL preserve extern "C" function declarations
8. THE Semantic_Analyzer SHALL verify that extern "C" functions use C-compatible types
9. THE Semantic_Analyzer SHALL verify that extern "C" functions do not use Rust-specific features incompatible with C ABI
10. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve extern "C" declarations in Crusty

### Requirement 45: Support Inline Assembly

**User Story:** As a Crusty programmer, I want to use inline assembly for low-level operations, so that I can write performance-critical or hardware-specific code.

#### Acceptance Criteria

1. THE Parser SHALL support __asm__ macro syntax with double-underscore naming (no ! suffix)
2. THE Parser SHALL support inline assembly within unsafe blocks
3. THE Parser SHALL support assembly templates with input and output operands
4. THE Parser SHALL support assembly options (e.g., nostack, readonly, nomem)
5. WHEN generating Rust code, THE Code_Generator SHALL translate __asm__ to Rust asm! (removing double-underscore prefix and suffix, adding !)
6. THE Semantic_Analyzer SHALL require __asm__ to be used within unsafe blocks
7. THE Semantic_Analyzer SHALL verify that __asm__ syntax is valid
8. THE Semantic_Analyzer SHALL prohibit function definitions named __asm__ (reserved for macro)
9. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust asm! to Crusty __asm__ (adding double-underscore prefix and suffix, removing !)

### Requirement 46: Support Embedding Raw Rust Code

**User Story:** As a Crusty programmer, I want to embed raw Rust code directly into Crusty programs, so that I can use Rust-specific features or syntax not yet supported by Crusty.

#### Acceptance Criteria

1. THE Parser SHALL support __rust__ macro syntax with double-underscore naming for embedding raw Rust code (no ! suffix)
2. THE Parser SHALL support __rust__ with block syntax (__rust__{ ... })
3. THE Parser SHALL treat the contents of __rust__ blocks as opaque Rust code
4. THE Parser SHALL support __rust__ in expression contexts
5. THE Parser SHALL support __rust__ in statement contexts
6. THE Parser SHALL support __rust__ in type contexts
7. WHEN generating Rust code, THE Code_Generator SHALL extract the contents of __rust__ blocks and emit them directly as Rust code
8. WHEN generating Rust code, THE Code_Generator SHALL preserve the exact formatting and syntax of embedded Rust code
9. THE Semantic_Analyzer SHALL NOT validate the contents of __rust__ blocks (validation deferred to rustc)
10. THE Semantic_Analyzer SHALL verify that __rust__ blocks are syntactically closed (matching braces)
11. THE Semantic_Analyzer SHALL prohibit function definitions named __rust__ (reserved for macro)
12. WHEN reverse transpiling from Rust, THE Code_Generator MAY wrap Rust-specific syntax in __rust__ blocks when no Crusty equivalent exists
13. THE Parser SHALL support nested braces within __rust__ blocks
14. THE crustyc documentation SHALL recommend using __rust__ as an escape hatch for unsupported features

## Control Flow and Pattern Matching

### Requirement 47: Support For Loop Variants

**User Story:** As a Crusty programmer, I want to use both Rust-style iterator loops and C-style for loops, so that I can write loops with familiar syntax that transpiles correctly.

#### Acceptance Criteria

1. THE Parser SHALL support Rust-style for-in loops (for item in collection { ... })
2. THE Parser SHALL support C-style for loops with initialization, condition, and increment (for (init; condition; increment) { ... })
3. WHEN a Rust-style for-in loop is encountered, THE Code_Generator SHALL pass it directly to Rust unchanged
4. WHEN a C-style for loop with a single variable is encountered, THE Code_Generator SHALL attempt to optimize it to Rust range syntax where possible
5. WHEN a C-style for loop matches the pattern for (var T i = start; i < end; i++), THE Code_Generator SHALL translate it to for i in start..end { ... }
6. WHEN a C-style for loop matches the pattern for (var T i = start; i <= end; i++), THE Code_Generator SHALL translate it to for i in start..=end { ... }
7. WHEN a C-style for loop has multiple variables in initialization, THE Code_Generator SHALL translate it to a scoped while loop
8. WHEN translating multi-variable C-style for loops, THE Code_Generator SHALL wrap the loop in a Rust block to constrain variable scope
9. WHEN translating multi-variable C-style for loops, THE Code_Generator SHALL place initialization statements at the start of the block
10. WHEN translating multi-variable C-style for loops, THE Code_Generator SHALL convert the loop to a while loop with the condition
11. WHEN translating multi-variable C-style for loops, THE Code_Generator SHALL append increment statements to the bottom of the while loop body after the original loop body content
12. THE Semantic_Analyzer SHALL verify that C-style for loop variables are properly scoped
13. WHEN reverse transpiling from Rust, THE Code_Generator SHALL preserve Rust for-in loops as Crusty for-in loops
14. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust range loops to appropriate Crusty syntax

### Requirement 48: Support Pattern Matching with Switch Statements

**User Story:** As a Crusty programmer, I want to use switch statements with pattern matching capabilities, so that I can write expressive control flow with familiar syntax.

#### Acceptance Criteria

1. THE Parser SHALL support switch statements with C-like syntax
2. THE Parser SHALL support case labels with single values
3. THE Parser SHALL support case labels with multiple comma-separated values
4. THE Parser SHALL support case labels with slice/array pattern matching syntax
5. THE Parser SHALL support default case for catch-all patterns
6. THE Parser SHALL NOT support implicit fallthrough between cases
7. WHEN generating code, THE Code_Generator SHALL translate switch statements to Rust match expressions
8. WHEN generating code, THE Code_Generator SHALL translate multiple case values to Rust OR patterns (|)
9. WHEN generating code, THE Code_Generator SHALL translate slice patterns to Rust slice pattern syntax
10. WHEN generating code, THE Code_Generator SHALL translate default case to Rust wildcard pattern (_)
11. THE Semantic_Analyzer SHALL verify switch statements are exhaustive or contain a default case
12. WHEN a switch statement is not exhaustive and lacks a default case, THE Semantic_Analyzer SHALL report an error

## Error Handling

### Requirement 49: Support Error Handling with Fallible Return Types

**User Story:** As a Crusty programmer, I want to handle errors with type-safe fallible return types, so that I can write robust code with clear error propagation.

#### Acceptance Criteria

1. THE Parser SHALL support ! suffix on return types to indicate fallible functions (Type!)
2. THE Parser SHALL support error(value) syntax for returning errors
3. THE Parser SHALL support ! operator for error propagation (similar to Rust's ? operator)
4. THE Parser SHALL support .is_error() method calls on fallible return values
5. THE Parser SHALL support .is_ok() method calls on fallible return values
6. THE Parser SHALL support .unwrap() method calls to extract success values
7. THE Parser SHALL support .unwrap_or(default) method calls to provide default values on error
8. WHEN generating Rust code, THE Code_Generator SHALL translate Type! to Result<Type, ErrorType>
9. WHEN generating Rust code, THE Code_Generator SHALL translate error(value) to Err(value)
10. WHEN generating Rust code, THE Code_Generator SHALL translate ! operator to Rust ? operator
11. WHEN generating Rust code, THE Code_Generator SHALL translate .is_error() to .is_err()
12. WHEN generating Rust code, THE Code_Generator SHALL translate .is_ok() to .is_ok()
13. WHEN generating Rust code, THE Code_Generator SHALL translate .unwrap() and .unwrap_or() to corresponding Rust methods
14. THE Semantic_Analyzer SHALL verify that fallible function calls are properly handled (propagated, checked, or unwrapped)
15. THE Semantic_Analyzer SHALL verify that ! operator is only used in functions with fallible return types
16. THE Parser SHALL support string literals as error values
17. THE Parser SHALL support enum values as error types
18. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Result<T, E> to Type!
19. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate ? operator to ! operator
20. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Err(value) to error(value)

## Module System and Visibility

### Requirement 50: Support Module Imports and Conditional Compilation

**User Story:** As a Crusty programmer, I want to import modules and use conditional compilation, so that I can organize code and support multiple platforms.

#### Acceptance Criteria

1. THE Parser SHALL support #use directives for module imports
2. WHEN a #use directive is encountered, THE Parser SHALL parse the module path
3. WHEN generating code, THE Code_Generator SHALL translate #use directives to Rust use statements
4. THE Parser SHALL support #ifdef directives for conditional compilation
5. THE Parser SHALL support #ifndef directives for conditional compilation
6. THE Parser SHALL support #endif directives to close conditional blocks
7. WHEN conditional compilation directives are encountered, THE Code_Generator SHALL translate them to Rust cfg attributes
8. THE Parser SHALL support nested conditional compilation blocks
9. WHEN #include is encountered, THE Parser SHALL reject it with an error message explaining to use #use instead
10. WHEN #define is encountered, THE Parser SHALL parse it as a macro definition
11. WHEN generating Rust code, THE Code_Generator SHALL translate #define macros to Rust macro_rules! definitions

### Requirement 51: Support Namespace Declarations for Module Organization

**User Story:** As a Crusty programmer, I want to declare namespaces using C++ style syntax, so that I can organize code into modules with familiar syntax.

#### Acceptance Criteria

1. THE Parser SHALL support namespace declarations with C++ syntax (namespace name { ... })
2. THE Parser SHALL support nested namespace declarations
3. THE Parser SHALL allow multiple namespace blocks with the same name in a single file
4. WHEN a namespace declaration is parsed, THE Semantic_Analyzer SHALL track the namespace scope for symbol resolution
5. WHEN generating Rust code, THE Code_Generator SHALL translate namespace declarations to Rust mod blocks
6. WHEN generating Rust code, THE Code_Generator SHALL merge multiple namespace blocks with the same name into a single mod block
7. WHEN reverse transpiling from Rust, THE Code_Generator SHALL translate Rust mod blocks to Crusty namespace declarations
8. THE Semantic_Analyzer SHALL enforce that symbols are accessed with appropriate namespace qualification

### Requirement 52: Support Symbol Visibility with Underscore Prefix Convention

**User Story:** As a Crusty programmer, I want to use underscore prefixes to mark symbols as private, so that I can control visibility with familiar conventions.

#### Acceptance Criteria

1. THE Parser SHALL recognize underscore-prefixed identifiers as private symbols
2. WHEN a struct field name begins with underscore, THE Code_Generator SHALL mark it as private in the generated Rust code
3. WHEN a struct field name does not begin with underscore, THE Code_Generator SHALL mark it as public in the generated Rust code
4. WHEN a function name begins with underscore and is not declared static, THE Code_Generator SHALL treat it as private
5. THE Semantic_Analyzer SHALL enforce that private symbols are only accessed within their defining module
6. WHEN a private symbol is accessed from outside its module, THE Semantic_Analyzer SHALL report an error

## Documentation

### Requirement 53: Extract Documentation from Source Code

**User Story:** As a Crusty programmer, I want to write documentation comments in my code, so that documentation can be automatically generated.

#### Acceptance Criteria

1. THE Parser SHALL recognize and preserve documentation comments in the AST
2. THE Parser SHALL support Rust-style outer doc comment syntax (/// and /** ... */)
3. THE Parser SHALL support Rust-style inner doc comment syntax (//! and /*! ... */)
4. THE Parser SHALL support standard line comments (//) and block comments (/* ... */)
5. WHEN parsing documentation comments, THE Doc_Extractor SHALL extract function descriptions
6. WHEN parsing documentation comments, THE Doc_Extractor SHALL extract parameter descriptions
7. WHEN parsing documentation comments, THE Doc_Extractor SHALL extract return value descriptions
8. WHEN parsing documentation comments, THE Doc_Extractor SHALL extract struct field descriptions
9. THE Doc_Extractor SHALL associate documentation with the corresponding code elements
10. WHEN generating Rust code, THE Code_Generator SHALL preserve all comment styles unchanged

### Requirement 54: Generate Documentation Using Kernel Document Object Model

**User Story:** As a Crusty programmer, I want to generate documentation from my code using crustydoc, so that I can maintain up-to-date documentation.

#### Acceptance Criteria

1. WHEN invoked with a source file path, THE crustydoc SHALL parse the file and extract documentation
2. WHEN documentation is extracted, THE Doc_Generator SHALL format it according to the Linux kernel document object model
3. WHEN generating documentation, THE Doc_Generator SHALL create structured output including function signatures
4. WHEN generating documentation, THE Doc_Generator SHALL include parameter descriptions with types
5. WHEN generating documentation, THE Doc_Generator SHALL include return value descriptions
6. WHEN generating documentation, THE Doc_Generator SHALL include struct definitions with field descriptions
7. WHERE an output format is specified, THE crustydoc SHALL generate documentation in that format (HTML, man pages, or text)
8. WHERE an output format is not specified, THE crustydoc SHALL default to HTML output
9. WHEN documentation generation completes, THE crustydoc SHALL write output files to the specified directory

### Requirement 55: Validate Documentation Completeness

**User Story:** As a Crusty programmer, I want to be warned about missing documentation, so that I can maintain complete documentation coverage.

#### Acceptance Criteria

1. WHEN crustydoc analyzes source code, THE Doc_Extractor SHALL identify public functions without documentation
2. WHEN crustydoc analyzes source code, THE Doc_Extractor SHALL identify public structs without documentation
3. WHEN undocumented public items are found, THE crustydoc SHALL report warnings with source locations
4. WHERE a strict mode is enabled, THE crustydoc SHALL treat missing documentation as errors
5. THE crustydoc SHALL report documentation coverage statistics

### Requirement 56: Provide crustyfmt Code Formatting Tool

**User Story:** As a Crusty developer, I want a code formatting tool similar to rustfmt, so that I can automatically format my Crusty code according to consistent style conventions.

#### Acceptance Criteria

1. THE project SHALL provide a crustyfmt binary tool for formatting Crusty source code
2. THE crustyfmt SHALL accept Crusty source files as input
3. THE crustyfmt SHALL parse Crusty source code into an AST
4. THE crustyfmt SHALL use the Pretty_Printer to generate formatted Crusty code from the AST
5. THE crustyfmt SHALL write formatted code back to the source file by default
6. THE crustyfmt SHALL support a --check flag that verifies formatting without modifying files
7. WHEN --check is used and files are not formatted, THE crustyfmt SHALL exit with non-zero status
8. THE crustyfmt SHALL support formatting multiple files in a single invocation
9. THE crustyfmt SHALL support formatting all .crst files in a directory recursively
10. THE crustyfmt SHALL preserve the semantic meaning of code while reformatting
11. THE crustyfmt SHALL apply consistent indentation (4 spaces for Crusty code)
12. THE crustyfmt SHALL apply consistent spacing around operators and delimiters
13. THE crustyfmt SHALL apply consistent line breaking for long statements
14. THE crustyfmt SHALL preserve documentation comments in their original positions
15. THE crustyfmt SHALL support a --config option to specify custom formatting rules
16. THE crustyfmt SHALL integrate with pre-commit hooks for automatic formatting
17. THE crustyfmt SHALL provide clear error messages when parsing fails
18. THE crustyfmt SHALL support stdin/stdout mode for editor integration
19. WHEN formatting is successful, THE crustyfmt SHALL exit with status 0
20. WHEN parsing or formatting fails, THE crustyfmt SHALL exit with non-zero status and display error details

## Bidirectional Transpilation

### Requirement 57: Support Reverse Transpilation from Rust to Crusty

**User Story:** As a developer, I want to transpile Rust code to Crusty syntax, so that I can convert existing Rust code or interoperate with Rust libraries.

#### Acceptance Criteria

1. THE crustyc SHALL support a --from-lang command-line option to specify the source language
2. WHEN --from-lang=rust is specified, THE crustyc SHALL parse the input file as Rust source code
3. WHEN --from-lang is not specified, THE crustyc SHALL default to parsing as Crusty source code
4. THE Rust_Parser SHALL parse Rust source files into an AST
5. WHEN generating Crusty code from Rust, THE Code_Generator SHALL translate Rust fn main() to Crusty main()
6. WHEN generating Crusty code from Rust, THE Code_Generator SHALL translate Rust pub functions to non-static Crusty functions
7. WHEN generating Crusty code from Rust, THE Code_Generator SHALL translate Rust private functions to static Crusty functions or underscore-prefixed names
8. WHEN generating Crusty code from Rust, THE Code_Generator SHALL translate Rust match expressions to Crusty switch statements
9. WHEN generating Crusty code from Rust, THE Code_Generator SHALL translate Rust use statements to Crusty #use directives
10. WHEN generating Crusty code from Rust, THE Code_Generator SHALL translate Rust const declarations to Crusty const declarations
11. WHEN generating Crusty code from Rust, THE Code_Generator SHALL translate Rust cfg attributes to Crusty #ifdef directives
12. WHEN generating Crusty code from Rust, THE Code_Generator SHALL preserve Rust doc comments in Crusty-compatible format
13. WHEN Rust features cannot be represented in Crusty, THE Transpiler SHALL report an error with explanation


## Testing and Validation

### Requirement 58: Provide Comprehensive Test Coverage for All Syntax Features

**User Story:** As a transpiler developer, I want comprehensive tests for all Crusty syntax features, so that I can ensure correctness and prevent regressions.

#### Acceptance Criteria

1. THE test suite SHALL include tests for all supported Crusty syntax features
2. THE test suite SHALL include tests for all type system features (primitive types, structs, enums, typedefs, type casting, sizeof)
3. THE test suite SHALL include tests for all variable declaration keywords (const, var, let, static)
4. THE test suite SHALL include tests for all reference and borrowing syntax (&, &var, &mut)
5. THE test suite SHALL include tests for all control flow structures (if/else-if/else, while, for variants, switch, break, continue)
6. THE test suite SHALL include tests for all operators (arithmetic, comparison, logical, bitwise, assignment, increment/decrement, ternary, member access, array subscript, address-of, dereference)
7. THE test suite SHALL include tests for pointer arithmetic within Rust constraints
8. THE test suite SHALL include tests for error handling syntax (Type!, error(), ! operator, unwrap methods)
9. THE test suite SHALL include tests for NULL and Option type mapping
10. THE test suite SHALL include tests for string types (String, &str, char arrays)
11. THE test suite SHALL include tests for #use directives importing standard Rust modules (std.collections, std.io, std.fs, etc.)
12. THE test suite SHALL validate that #use directives correctly map to Rust use statements for cross-tool compatibility
13. THE test suite SHALL include tests for conditional compilation directives (#ifdef, #ifndef, #endif)
14. THE test suite SHALL include tests for namespace declarations and nested namespaces
15. THE test suite SHALL include tests for symbol visibility (static functions, underscore-prefixed symbols)
16. THE test suite SHALL include tests for documentation comment extraction (///, //!, /** */, /*! */)
17. THE test suite SHALL include tests for main() entry point variants (no parameters, argc/argv)
18. THE test suite SHALL include tests for function declarations (static/non-static, void/non-void return types)
19. THE test suite SHALL include tests for all for loop variants (Rust-style for-in, simple C-style, multi-variable C-style)
20. THE test suite SHALL include tests for bidirectional transpilation (CrustyRustCrusty round-trip)
21. THE test suite SHALL include tests that verify generated Rust code compiles successfully with rustc
22. THE test suite SHALL include tests that verify generated Rust code produces correct runtime behavior
23. THE test suite SHALL include negative tests for unsupported features (unions, #include, goto)
24. THE test suite SHALL include positive tests for #define macro definitions and their translation to Rust macro_rules!
25. WHEN a syntax feature is added or modified, THE test suite SHALL be updated to include corresponding tests
26. THE test suite SHALL achieve at least 90% code coverage of the Parser, Semantic_Analyzer, and Code_Generator components
