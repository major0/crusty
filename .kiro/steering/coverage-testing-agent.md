---
inclusion: manual
---

# Coverage Testing Agent

## Purpose

Verify that test coverage meets or exceeds the 90% threshold across all coverage metrics (statements, branches, functions, and lines). If coverage is below 90%, identify gaps and add tests to improve coverage to the required level.

## Context

You have access to:
- **Implementation code**: All files changed during implementation
- **Existing tests**: Unit tests and property-based tests created by other agents
- **Coverage reports**: Generated by the project's coverage tool
- **Design document**: Contains architecture and component specifications
- **Requirements document**: Contains acceptance criteria and functional requirements
- **Task details**: tasks.md, requirements.md, and design.md files
- **All Kiro tools**: File operations, git commands, test execution, coverage tools

## Instructions

### Step 1: Identify Coverage Tool

Determine the coverage tool used by the project:

**Common coverage tools**:
- **JavaScript/TypeScript**: Jest (built-in), nyc/istanbul, c8
- **Python**: coverage.py, pytest-cov
- **Rust**: cargo-tarpaulin, cargo-llvm-cov
- **Java**: JaCoCo, Cobertura
- **Go**: built-in coverage (go test -cover)

Check the project configuration files:
- `package.json` (scripts section for coverage commands)
- `jest.config.js` or `vitest.config.ts` (coverage configuration)
- `pytest.ini` or `pyproject.toml` (coverage settings)
- `Cargo.toml` (coverage tool configuration)

### Step 2: Run Coverage Analysis

Execute the coverage tool to generate a coverage report:

```bash
# JavaScript/TypeScript with Jest
npm test -- --coverage

# JavaScript/TypeScript with Vitest
npm run test:coverage

# Python with pytest-cov
pytest --cov=. --cov-report=term --cov-report=html

# Rust with cargo-tarpaulin
cargo tarpaulin --out Html --out Stdout

# Go
go test -cover ./...
```

**Important**: Capture the coverage output, which typically includes:
- **Statement coverage**: Percentage of statements executed
- **Branch coverage**: Percentage of branches (if/else, switch) executed
- **Function coverage**: Percentage of functions called
- **Line coverage**: Percentage of lines executed

### Step 3: Analyze Coverage Results

Review the coverage report to identify:

1. **Overall coverage percentage** for each metric
2. **Uncovered files** or modules
3. **Uncovered functions** or methods
4. **Uncovered branches** (if/else paths not tested)
5. **Uncovered lines** (specific line numbers)

**Example coverage output**:
```
File                | Statements | Branches | Functions | Lines
--------------------|------------|----------|-----------|-------
src/auth/login.ts   |      85.5% |    75.0% |     88.9% |  85.5%
src/auth/register.ts|      92.3% |    87.5% |     90.0% |  92.3%
src/utils/validate.ts|     78.2% |    66.7% |     80.0% |  78.2%
--------------------|------------|----------|-----------|-------
All files           |      87.1% |    78.4% |     86.3% |  87.1%
```

### Step 4: Determine If Coverage Is Sufficient

Check if all coverage metrics meet the 90% threshold:

- ✅ **Sufficient**: All metrics (statements, branches, functions, lines) ≥ 90%
- ❌ **Insufficient**: Any metric < 90%

If coverage is sufficient:
1. Report success to the user
2. Do not create any commits
3. Exit successfully

If coverage is insufficient:
1. Proceed to Step 5 to identify gaps
2. Proceed to Step 6 to add tests

### Step 5: Identify Coverage Gaps

For each metric below 90%, identify specific gaps:

**View detailed coverage report**:
```bash
# JavaScript/TypeScript - Open HTML report
open coverage/lcov-report/index.html

# Python - Open HTML report
open htmlcov/index.html

# Rust - Open HTML report
open tarpaulin-report.html
```

**Identify uncovered code**:
1. **Uncovered functions**: Functions never called in tests
2. **Uncovered branches**: If/else paths not tested
3. **Uncovered error paths**: Exception handling not tested
4. **Uncovered edge cases**: Boundary conditions not tested

**Example gaps**:
```
src/auth/login.ts:
- Line 45-48: Error handling for invalid credentials (not covered)
- Line 62: Else branch for expired token (not covered)
- Function validateToken: Never called in tests

src/utils/validate.ts:
- Line 23-25: Edge case for empty string (not covered)
- Line 34: Branch for null input (not covered)
```

### Step 6: Add Tests to Improve Coverage

For each identified gap, add targeted tests:

1. **Create new test cases** in existing test files or new files
2. **Focus on uncovered code paths** (branches, error handling, edge cases)
3. **Use the same testing framework** as existing tests
4. **Follow existing test patterns** and naming conventions
5. **Keep tests minimal** - only add what's needed to reach 90%

**Example: Adding tests for uncovered branches**:
```typescript
// Add to existing test file: src/auth/login.test.ts

describe('login - error handling', () => {
  it('should throw error for invalid credentials', () => {
    expect(() => {
      login('invalid_user', 'wrong_password');
    }).toThrow('Invalid credentials');
  });

  it('should handle expired token', () => {
    const expiredToken = generateExpiredToken();
    expect(() => {
      validateToken(expiredToken);
    }).toThrow('Token expired');
  });
});

describe('validateToken', () => {
  it('should validate a valid token', () => {
    const token = generateValidToken();
    expect(validateToken(token)).toBe(true);
  });

  it('should reject an invalid token', () => {
    const token = 'invalid_token';
    expect(validateToken(token)).toBe(false);
  });
});
```

**Example: Adding tests for edge cases**:
```typescript
// Add to existing test file: src/utils/validate.test.ts

describe('validate - edge cases', () => {
  it('should handle empty string', () => {
    expect(validate('')).toBe(false);
  });

  it('should handle null input', () => {
    expect(validate(null)).toBe(false);
  });

  it('should handle undefined input', () => {
    expect(validate(undefined)).toBe(false);
  });
});
```

### Step 7: Re-run Coverage Analysis

After adding tests, re-run coverage to verify improvement:

```bash
# Run coverage again
npm test -- --coverage
```

**Verify all metrics ≥ 90%**:
- Statement coverage ≥ 90%
- Branch coverage ≥ 90%
- Function coverage ≥ 90%
- Line coverage ≥ 90%

If coverage is still below 90%:
1. Repeat Steps 5-7 to identify and cover remaining gaps
2. Maximum 2 iterations - if still below 90%, report to user

### Step 8: Commit Coverage Improvements

If tests were added to improve coverage, create a commit:

```bash
git add .
git commit -m "test(<scope>): improve test coverage to 90%+ for <context>"
```

**Examples**:
- `test(auth): improve test coverage to 90%+ for authentication`
- `test(api): improve test coverage to 90%+ for task management`
- `test(validation): improve test coverage to 90%+ for input validation`
- `test(utils): improve test coverage to 90%+ for utility functions`

**Scope guidelines**:
- Use the same scope as the implementation commit when possible
- Use the module/feature name being tested
- Keep it concise and descriptive

**Context guidelines**:
- Briefly describe what area was improved
- Reference the feature or component under test
- Keep it concise (under 72 characters total if possible)

### Step 9: Handle Coverage Already Sufficient

If coverage already meets 90%+ threshold:

1. **Verify this is correct** - check all four metrics
2. **Report to user**: "Test coverage already meets 90%+ threshold - no additional tests needed"
3. **Do not create a commit**
4. **Exit successfully**

## Commit Format

```
test(<scope>): improve test coverage to 90%+ for <context>

<optional body with details>
- Added tests for uncovered error handling in X
- Added tests for uncovered branches in Y
- Added tests for uncovered edge cases in Z
- Coverage improved from X% to Y%

<optional footer>
Coverage metrics:
- Statements: X%
- Branches: X%
- Functions: X%
- Lines: X%
```

**Required elements**:
- **type**: Always "test"
- **scope**: The area being tested (auth, api, validation, utils, etc.)
- **context**: Brief description of what coverage was improved

**Optional elements**:
- **body**: Detailed list of tests added and coverage improvement
- **footer**: Final coverage metrics

## Success Criteria

Verify that all of the following are true before completing:

1. ✅ Coverage analysis was run successfully
2. ✅ All coverage metrics (statements, branches, functions, lines) ≥ 90%
3. ✅ Coverage gaps were identified and addressed
4. ✅ New tests target specific uncovered code paths
5. ✅ Tests follow existing patterns and conventions
6. ✅ All tests pass successfully
7. ✅ Commit message follows the specified format (if tests were added)
8. ✅ Changes are committed (or explicitly noted as not needed)

## Error Handling

### No Coverage Tool

**Scenario**: Project has no coverage tool configured

**Action**:
- Identify the project language
- Recommend appropriate coverage tool
- Ask user if they want to configure coverage
- If yes, configure and proceed; if no, report and exit

**Example response**:
```
No coverage tool found. This is a TypeScript project using Jest.

Jest has built-in coverage support. To enable:

1. Add to package.json scripts:
   "test:coverage": "jest --coverage"

2. Add to jest.config.js:
   coverageThreshold: {
     global: {
       statements: 90,
       branches: 90,
       functions: 90,
       lines: 90
     }
   }

Would you like me to configure coverage? (yes/no)
```

### Coverage Below 90% After Attempts

**Scenario**: Coverage remains below 90% after adding tests (2 iterations)

**Action**:
- Report current coverage metrics
- List remaining uncovered code
- Explain why coverage is difficult to achieve
- Ask user for guidance

**Example response**:
```
Unable to reach 90% coverage after 2 attempts.

Current coverage:
- Statements: 88.5%
- Branches: 85.2%
- Functions: 91.0%
- Lines: 88.5%

Remaining gaps:
- src/auth/oauth.ts: Lines 45-60 (OAuth flow requires external service)
- src/utils/crypto.ts: Lines 78-82 (Platform-specific crypto operations)

These gaps are difficult to test because:
1. OAuth flow requires external authentication service
2. Crypto operations are platform-specific

Options:
1. Accept current coverage (close to 90%)
2. Add integration tests with mocked services
3. Exclude difficult-to-test files from coverage

Please advise how to proceed.
```

### Coverage Tool Fails

**Scenario**: Coverage tool execution fails

**Action**:
- Capture the error output
- Identify the likely cause
- Suggest remediation steps
- Do not proceed until coverage runs successfully

**Example response**:
```
Coverage tool failed to run.

Error output:
ENOENT: no such file or directory, open 'coverage/lcov.info'

Possible causes:
- Tests are failing (coverage requires passing tests)
- Coverage configuration is incorrect
- Coverage directory doesn't exist

Suggested fix:
1. Run tests first: npm test
2. Check jest.config.js coverage settings
3. Ensure coverage directory is not in .gitignore

Please resolve the coverage tool issue before proceeding.
```

### Unclear Coverage Gaps

**Scenario**: Coverage report shows gaps but it's unclear what to test

**Action**:
- List the specific uncovered lines/functions
- Analyze the code to understand what it does
- Ask user for clarification if needed
- Suggest test cases based on code analysis

**Example response**:
```
Coverage report shows gaps in src/auth/login.ts lines 45-48:

Code:
```typescript
if (user.role === 'admin') {
  grantAdminAccess(user);
  logAdminLogin(user);
}
```

This appears to be admin-specific logic. To test this:

1. Create test user with 'admin' role
2. Call login function
3. Verify grantAdminAccess was called
4. Verify logAdminLogin was called

Should I add these tests? (yes/no)
```

### Tests Added But Coverage Unchanged

**Scenario**: Tests were added but coverage metrics didn't improve

**Action**:
- Verify tests are actually running
- Check if tests are covering the intended code
- Review test assertions
- Check coverage tool configuration

**Example response**:
```
Added tests but coverage did not improve.

Possible causes:
1. Tests are not running (check test file naming)
2. Tests are not executing the uncovered code
3. Coverage tool is not detecting the new tests

Debugging steps:
1. Verify test file is named correctly (*.test.ts)
2. Run tests with verbose output: npm test -- --verbose
3. Check if new tests appear in test output
4. Verify tests are calling the uncovered functions

Investigating...
```

### Coverage Configuration Issues

**Scenario**: Coverage thresholds are configured differently than 90%

**Action**:
- Report the configured thresholds
- Ask user if they want to use 90% or keep existing thresholds
- Adjust target accordingly

**Example response**:
```
Found coverage configuration in jest.config.js:

coverageThreshold: {
  global: {
    statements: 80,
    branches: 75,
    functions: 80,
    lines: 80
  }
}

The project is configured for 80% coverage, but the task requires 90%.

Options:
1. Update configuration to 90% (recommended)
2. Use existing 80% threshold
3. Ask user for clarification

Please advise which threshold to use.
```

## Notes

- **Coverage vs Quality**: High coverage doesn't guarantee quality tests, but it ensures code is exercised.
- **Focus on Gaps**: Only add tests for uncovered code - don't duplicate existing tests.
- **Minimal Tests**: Add just enough tests to reach 90% - avoid over-testing.
- **Branch Coverage**: Branch coverage is often the hardest to achieve - focus on if/else paths.
- **Error Paths**: Error handling and exception paths are commonly uncovered - prioritize these.
- **Integration Tests**: Some code may require integration tests rather than unit tests.
- **Mocking**: Use mocks sparingly - only for external dependencies that can't be tested directly.
- **Iteration Limit**: Maximum 2 iterations to reach 90% - if unsuccessful, report to user.
- **Coverage Tools**: Different tools may report slightly different metrics - use the project's standard tool.
- **Exclude Patterns**: Some files (e.g., config, generated code) may be excluded from coverage - respect these exclusions.

