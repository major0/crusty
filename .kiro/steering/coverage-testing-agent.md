---
inclusion: manual
---

# Coverage Testing Agent

## Purpose

Verify that test coverage meets or exceeds the 90% threshold across all coverage metrics (statements, branches, functions, and lines) using cargo-tarpaulin or cargo-llvm-cov. If coverage is below 90%, identify gaps and add tests to improve coverage to the required level.

## Context

You have access to:
- **Implementation code**: All Rust files changed during implementation
- **Existing tests**: Unit tests and property-based tests created by other agents
- **Coverage reports**: Generated by cargo-tarpaulin or cargo-llvm-cov
- **Design document**: Contains architecture and component specifications
- **Requirements document**: Contains acceptance criteria and functional requirements
- **Task details**: tasks.md, requirements.md, and design.md files
- **All Kiro tools**: File operations, git commands, test execution, coverage tools

## Instructions

### Step 1: Identify Coverage Tool

This project uses **cargo-tarpaulin** for code coverage:

**Install tarpaulin** (if not already installed):
```bash
cargo install cargo-tarpaulin
```

**Alternative**: cargo-llvm-cov (if preferred):
```bash
rustup component add llvm-tools-preview
cargo install cargo-llvm-cov
```

### Step 2: Run Coverage Analysis

Execute the coverage tool to generate a coverage report:

**Using cargo-tarpaulin**:
```bash
# Run coverage with HTML and stdout output
cargo tarpaulin --out Html --out Stdout

# Run with specific options
cargo tarpaulin --out Html --out Stdout --exclude-files 'tests/*' --timeout 300
```

**Using cargo-llvm-cov**:
```bash
# Run coverage
cargo llvm-cov --html

# Run with specific options
cargo llvm-cov --html --ignore-filename-regex 'tests'
```

**Coverage output includes**:
- **Line coverage**: Percentage of lines executed
- **Branch coverage**: Percentage of branches (if/else, match) executed
- **Function coverage**: Percentage of functions called
- **Statement coverage**: Percentage of statements executed

### Step 3: Analyze Coverage Results

Review the coverage report to identify:

1. **Overall coverage percentage** for each metric
2. **Uncovered files** or modules
3. **Uncovered functions** or methods
4. **Uncovered branches** (if/else paths not tested)
5. **Uncovered lines** (specific line numbers)

**Example coverage output**:
```
|| Tested/Total Lines:
|| src/parser.rs: 145/170 (85.3%)
|| src/codegen.rs: 180/195 (92.3%)
|| src/semantic.rs: 120/154 (77.9%)
||
|| Total Coverage: 445/519 (85.7%)
```

### Step 4: Determine If Coverage Is Sufficient

Check if all coverage metrics meet the 90% threshold:

- ✅ **Sufficient**: All metrics (statements, branches, functions, lines) ≥ 90%
- ❌ **Insufficient**: Any metric < 90%

If coverage is sufficient:
1. Report success to user
2. Do not create any commits
3. Exit successfully

If coverage is insufficient:
1. Proceed to Step 5 to identify gaps
2. Proceed to Step 6 to add tests

### Step 5: Identify Coverage Gaps

For each metric below 90%, identify specific gaps:

**View detailed coverage report**:
```bash
# Open HTML report
open tarpaulin-report.html

# Or view in terminal
cargo tarpaulin --out Stdout
```

**Identify uncovered code**:
1. **Uncovered functions**: Functions never called in tests
2. **Uncovered branches**: If/else/match arms not tested
3. **Uncovered error paths**: Result::Err cases not tested
4. **Uncovered edge cases**: Boundary conditions not tested

**Example gaps**:
```
src/parser.rs:
- Line 45-48: Error handling for invalid syntax (not covered)
- Line 62: Else branch for empty input (not covered)
- Function parse_complex_expr: Never called in tests

src/semantic.rs:
- Line 23-25: Edge case for empty type list (not covered)
- Line 34: Match arm for None case (not covered)
```

### Step 6: Add Tests to Improve Coverage

For each identified gap, add targeted tests:

1. **Create new test cases** in existing test modules or new files
2. **Focus on uncovered code paths** (branches, error handling, edge cases)
3. **Use Rust's test framework** with `#[test]` attribute
4. **Follow existing test patterns** and naming conventions
5. **Keep tests minimal** - only add what's needed to reach 90%

**Example: Adding tests for uncovered branches**:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_error_handling() {
        let result = parse_function("invalid syntax");
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "Parse error: invalid syntax"
        );
    }

    #[test]
    fn test_parse_empty_input() {
        let result = parse_function("");
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_complex_expr() {
        let input = "int x = (a + b) * (c - d);";
        let result = parse_complex_expr(input);
        assert!(result.is_ok());
    }
}
```

**Example: Adding tests for edge cases**:
```rust
#[test]
fn test_semantic_empty_type_list() {
    let types = vec![];
    let result = validate_types(&types);
    assert!(result.is_ok());
}

#[test]
fn test_semantic_none_case() {
    let opt_type = None;
    let result = process_optional_type(opt_type);
    assert_eq!(result, default_type());
}
```

### Step 7: Re-run Coverage Analysis

After adding tests, re-run coverage to verify improvement:

```bash
# Run coverage again
cargo tarpaulin --out Html --out Stdout
```

**Verify all metrics ≥ 90%**:
- Line coverage ≥ 90%
- Branch coverage ≥ 90%
- Function coverage ≥ 90%
- Statement coverage ≥ 90%

If coverage is still below 90%:
1. Repeat Steps 5-7 to identify and cover remaining gaps
2. Maximum 2 iterations - if still below 90%, report to user

### Step 8: Commit Coverage Improvements

If tests were added to improve coverage, create a commit:

```bash
git add .
git commit -m "test(<scope>): improve test coverage to 90%+ for <context>"
```

**Examples**:
- `test(parser): improve test coverage to 90%+ for parser module`
- `test(codegen): improve test coverage to 90%+ for code generation`
- `test(semantic): improve test coverage to 90%+ for semantic analysis`

**Scope guidelines**:
- Use the same scope as implementation commit
- Use module name (parser, codegen, semantic, etc.)

## Commit Format

```
test(<scope>): improve test coverage to 90%+ for <context>

<optional body>
- Added tests for uncovered error handling in X
- Added tests for uncovered branches in Y
- Added tests for uncovered edge cases in Z
- Coverage improved from X% to Y%

<optional footer>
Coverage metrics:
- Lines: X%
- Branches: X%
- Functions: X%
- Statements: X%
```

## Success Criteria

1. ✅ Coverage analysis ran successfully
2. ✅ All coverage metrics (lines, branches, functions, statements) ≥ 90%
3. ✅ Coverage gaps identified and addressed
4. ✅ New tests target specific uncovered code paths
5. ✅ Tests follow existing patterns and conventions
6. ✅ All tests pass successfully
7. ✅ Commit message follows format (if tests added)
8. ✅ Changes committed (or noted as not needed)

## Error Handling

### Coverage Tool Not Installed

**Scenario**: cargo-tarpaulin or cargo-llvm-cov not installed

**Action**:
- Report error
- Suggest installation: `cargo install cargo-tarpaulin`
- Exit without proceeding

### Coverage Tool Execution Fails

**Scenario**: Coverage tool fails to run

**Action**:
- Capture error output
- Check if tests are failing (coverage requires passing tests)
- Report to user
- Do not proceed until coverage runs successfully

### Coverage Below 90% After Attempts

**Scenario**: Coverage remains below 90% after adding tests (2 iterations)

**Action**:
- Report current coverage metrics
- List remaining uncovered code
- Explain why coverage is difficult to achieve
- Ask user for guidance

**Example response**:
```
Unable to reach 90% coverage after 2 attempts.

Current coverage:
- Lines: 88.5%
- Branches: 85.2%
- Functions: 91.0%
- Statements: 88.5%

Remaining gaps:
- src/parser.rs: Lines 45-60 (complex error recovery logic)
- src/codegen.rs: Lines 78-82 (platform-specific code)

These gaps are difficult to test because:
1. Error recovery requires specific parse states
2. Platform-specific code requires different OS

Options:
1. Accept current coverage (close to 90%)
2. Add integration tests for complex scenarios
3. Exclude difficult-to-test code from coverage

Please advise how to proceed.
```

### Tests Added But Coverage Unchanged

**Scenario**: Tests added but coverage didn't improve

**Action**:
- Verify tests are actually running
- Check if tests execute the uncovered code
- Review test assertions
- Check coverage tool configuration

## Notes

- **Coverage vs Quality**: High coverage doesn't guarantee quality tests, but ensures code is exercised
- **Focus on Gaps**: Only add tests for uncovered code - don't duplicate existing tests
- **Minimal Tests**: Add just enough tests to reach 90% - avoid over-testing
- **Branch Coverage**: Branch coverage is often hardest to achieve - focus on if/else/match paths
- **Error Paths**: Error handling and Result::Err paths are commonly uncovered - prioritize these
- **Integration Tests**: Some code may require integration tests rather than unit tests
- **Iteration Limit**: Maximum 2 iterations to reach 90% - if unsuccessful, report to user
- **Exclude Patterns**: Some files (e.g., generated code) may be excluded from coverage
- **CI/CD Integration**: Coverage is verified in CI/CD pipeline with 90% threshold
